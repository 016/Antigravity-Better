<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <script>
  // === AG-Better: React Fiber Bridge for Cascade Tab Switching ===
  // Accesses Cascade's React component tree to read conversation list and switch conversations.
  // This is the proven approach discovered via CDP deep testing (T1.0-T1.4).
  (function() {
    'use strict';
    try {
      if (localStorage.getItem('ag-better-bridge-enabled') === 'false') return;

      const FIBER_POLL_INTERVAL = 3000;
      const MAX_FIBER_DEPTH = 500;
      let _fiberSuffix = null;
      let _cascadeContext = null;
      let _lastConversations = [];
      let _currentCascadeId = null;

      // Find React fiber suffix (e.g., 'iz359v3fbbm')
      function findFiberSuffix() {
        if (_fiberSuffix) return _fiberSuffix;
        const all = document.querySelectorAll('*');
        for (let i = 0; i < all.length; i++) {
          const keys = Object.keys(all[i]);
          for (let k = 0; k < keys.length; k++) {
            if (keys[k].startsWith('__reactContainer$')) {
              _fiberSuffix = keys[k].replace('__reactContainer$', '');
              return _fiberSuffix;
            }
          }
        }
        return null;
      }

      // Get React container from #react-app
      function getReactContainer() {
        const suffix = findFiberSuffix();
        if (!suffix) return null;
        const reactApp = document.getElementById('react-app');
        if (!reactApp) return null;
        return reactApp['__reactContainer$' + suffix] || null;
      }

      // Traverse fiber tree to find cascade context provider
      function findCascadeContext() {
        const container = getReactContainer();
        if (!container) return null;

        const visited = new WeakSet();
        const queue = [container];
        let count = 0;

        while (queue.length > 0 && count < MAX_FIBER_DEPTH) {
          const f = queue.shift();
          if (!f || visited.has(f)) continue;
          visited.add(f);
          count++;

          if (f.memoizedProps && f.memoizedProps.value && typeof f.memoizedProps.value === 'object') {
            const val = f.memoizedProps.value;
            if (val.events && val.state && val.layout && val.events.setCascadeConversationState) {
              _cascadeContext = val;
              return val;
            }
          }
          if (f.child) queue.push(f.child);
          if (f.sibling) queue.push(f.sibling);
        }
        return null;
      }

      // Find conversation list component (uses prop shape matching, not component name)
      function findConversationList() {
        const container = getReactContainer();
        if (!container) return _lastConversations;

        const visited = new WeakSet();
        const queue = [container];
        let count = 0;
        let listComponent = null;

        while (queue.length > 0 && count < MAX_FIBER_DEPTH) {
          const f = queue.shift();
          if (!f || visited.has(f)) continue;
          visited.add(f);
          count++;

          // Match by prop shape: component with cascadeIds array prop
          if (f.memoizedProps && Array.isArray(f.memoizedProps.cascadeIds) && f.memoizedProps.cascadeIds.length > 0) {
            listComponent = f;
            break;
          }
          if (f.child) queue.push(f.child);
          if (f.sibling) queue.push(f.sibling);
        }

        // If not mounted (e.g., viewing a conversation), return cached data
        if (!listComponent) return _lastConversations;

        // Get cascadeIds from props
        const cascadeIds = listComponent.memoizedProps.cascadeIds;

        // Search state chain for summaries object (keyed by UUID)
        let summaries = {};
        let state = listComponent.memoizedState;
        let sIdx = 0;
        while (state && sIdx < 15) {
          if (state.memoizedState && typeof state.memoizedState === 'object' && !Array.isArray(state.memoizedState)) {
            const ms = state.memoizedState;
            // Check if this is the summaries map (has .summaries key or is directly UUID-keyed)
            if (ms.summaries && typeof ms.summaries === 'object') {
              summaries = ms.summaries;
              break;
            }
            // useRef æ¨¡å¼: { current: { [uuid]: ... } }
            if (ms.current && typeof ms.current === 'object' && !Array.isArray(ms.current)) {
              const ck = Object.keys(ms.current);
              if (ck.length > 0 && /^[0-9a-f]{8}-/.test(ck[0])) {
                summaries = ms.current;
                break;
              }
            }
            // Check if keys look like UUIDs
            const keys = Object.keys(ms);
            if (keys.length > 0 && /^[0-9a-f]{8}-/.test(keys[0])) {
              summaries = ms;
              break;
            }
          }
          state = state.next;
          sIdx++;
        }

        // Build conversation list â€” å…¼å®¹å¤šç§å­—æ®µå‘½å
        const conversations = cascadeIds.map(id => {
          const raw = summaries[id];
          let info = {};
          if (typeof raw === 'string') {
            // ç›´æ¥ä»¥å­—ç¬¦ä¸²å­˜å‚¨ summary
            info = { summary: raw };
          } else if (raw && typeof raw === 'object') {
            info = raw;
          }
          return {
            cascadeId: id,
            summary: info.summary || info.name || info.title || info.displayName || '',
            lastModifiedTime: info.lastModifiedTime || '',
            status: info.status || '',
            stepCount: info.stepCount || 0
          };
        });

        _lastConversations = conversations;
        return conversations;
      }

      // Get current cascade ID
      function getCurrentCascadeId() {
        const ctx = findCascadeContext();
        if (ctx && ctx.state && ctx.state.cascadeState) {
          _currentCascadeId = ctx.state.cascadeState.cascadeId || null;
          return _currentCascadeId;
        }
        return _currentCascadeId;
      }

      // Switch to a conversation by cascadeId
      function switchConversation(cascadeId) {
        const ctx = findCascadeContext();
        if (!ctx || !ctx.events || !ctx.events.setCascadeConversationState) {
          return false;
        }
        try {
          ctx.events.setCascadeConversationState({ cascadeId: cascadeId });
          _currentCascadeId = cascadeId;
          return true;
        } catch (e) {
          return false;
        }
      }

      // Start new conversation (clear cascade ID)
      function startNewConversation() {
        const ctx = findCascadeContext();
        if (!ctx || !ctx.events || !ctx.events.clearCascadeId) {
          return false;
        }
        try {
          ctx.events.clearCascadeId();
          _currentCascadeId = null;
          return true;
        } catch (e) {
          return false;
        }
      }

      // Find conversation title from multiple sources
      function findConversationTitle(cascadeId) {
        if (!cascadeId) return null;

        // Source 1: conversation list cache
        try {
          const convos = findConversationList();
          const match = convos.find(c => c.cascadeId === cascadeId);
          if (match && match.summary) return match.summary;
        } catch (e) { /* ignore */ }

        // Source 2: cascade context state â€” æ£€æŸ¥å¤šç§å­—æ®µå
        try {
          const ctx = findCascadeContext();
          if (ctx && ctx.state) {
            const cs = ctx.state.cascadeState || {};
            if (cs.cascadeId === cascadeId) {
              const t = cs.summary || cs.title || cs.name || cs.displayName;
              if (t) return t;
            }
            // æ£€æŸ¥ state ä¸­æ˜¯å¦æœ‰ conversations mapï¼ˆå¤šç§å¯èƒ½çš„å­—æ®µåï¼‰
            const convMaps = [ctx.state.conversations, ctx.state.cascadeConversations, ctx.state.conversationMap];
            for (const convMap of convMaps) {
              if (convMap && typeof convMap === 'object') {
                const c = convMap[cascadeId];
                if (c) {
                  const t = typeof c === 'string' ? c : (c.summary || c.title || c.name || c.displayName);
                  if (t) return t;
                }
              }
            }
          }
        } catch (e) { /* ignore */ }

        // Source 3: scan fiber tree for props/state containing this cascadeId
        try {
          const container = getReactContainer();
          if (container) {
            const visited = new WeakSet();
            const queue = [container];
            let count = 0;
            while (queue.length > 0 && count < MAX_FIBER_DEPTH) {
              const f = queue.shift();
              if (!f || visited.has(f)) continue;
              visited.add(f);
              count++;

              // æ£€æŸ¥ props ä¸­çš„ cascadeId + summary/title/name
              const p = f.memoizedProps;
              if (p && typeof p === 'object') {
                if (p.cascadeId === cascadeId) {
                  const t = p.summary || p.title || p.name || p.displayName;
                  if (t) return t;
                }
                // æ£€æŸ¥ props.conversation æˆ– props.data ä¸­æ˜¯å¦æœ‰æ ‡é¢˜
                const nested = p.conversation || p.data || p.item;
                if (nested && typeof nested === 'object' && nested.cascadeId === cascadeId) {
                  const t = nested.summary || nested.title || nested.name;
                  if (t) return t;
                }
              }

              // Source 4: æ£€æŸ¥ memoizedState é“¾ä¸­æ˜¯å¦æœ‰ cascadeId å…³è”çš„æ ‡é¢˜
              let st = f.memoizedState;
              let si = 0;
              while (st && si < 8) {
                const ms = st.memoizedState;
                if (ms && typeof ms === 'object' && !Array.isArray(ms)) {
                  // ç›´æ¥æ£€æŸ¥æ˜¯å¦æœ‰ cascadeId ä½œä¸º key
                  const entry = ms[cascadeId] || (ms.current && ms.current[cascadeId]);
                  if (entry) {
                    const t = typeof entry === 'string' ? entry : (entry.summary || entry.title || entry.name || entry.displayName);
                    if (t) return t;
                  }
                }
                st = st.next;
                si++;
              }

              if (f.child) queue.push(f.child);
              if (f.sibling) queue.push(f.sibling);
            }
          }
        } catch (e) { /* ignore */ }

        // Source 5: DOM æ ‡é¢˜æå– â€” ä»…å¯¹å½“å‰æ´»è·ƒå¯¹è¯æœ‰æ•ˆ
        // Cascade é¢æ¿é¡¶éƒ¨æœ‰ä¸€ä¸ª <p> å…ƒç´ æ˜¾ç¤ºå½“å‰å¯¹è¯æ ‡é¢˜
        try {
          if (_currentCascadeId === cascadeId || getCurrentCascadeId() === cascadeId) {
            const titleEl = document.querySelector('p[class*="text-ellipsis"][class*="whitespace-nowrap"]');
            if (titleEl) {
              const text = (titleEl.textContent || '').trim();
              if (text && text.length > 0 && text.length < 100) return text;
            }
          }
        } catch (e) { /* ignore */ }

        return null;
      }

      // Detect busy (generating) conversations
      // 'active' å’Œ 'pending' å·²ç§»é™¤ï¼š'active' åŒ¹é…æ‰€æœ‰æ‰“å¼€çš„å¯¹è¯ï¼Œ'pending' åŒ¹é…ç­‰å¾…ä¸­çš„å¯¹è¯ï¼Œå‡éç”ŸæˆçŠ¶æ€
      const BUSY_STATUSES = ['in_progress', 'generating', 'streaming', 'running', 'processing'];
      // æ•°å­—çŠ¶æ€æ˜ å°„ï¼šéœ€é€šè¿‡ diagnoseBusy() åœ¨ç”Ÿæˆä¸­æ•è·å®é™…å¿™ç¢Œå€¼åå¡«å…¥
      // CDP è°ƒè¯•ç¡®è®¤ 1 = idleï¼Œå…¶ä»–å€¼å¾…ç¡®è®¤
      const NUMERIC_BUSY_STATUSES = new Set();
      const _discoveredStatuses = new Set();

      function getBusyConversations() {
        const busyIds = new Set();
        let _layer1HasData = false;

        // Layer 1: Check conversation list status fields
        try {
          const convos = findConversationList();
          if (convos.length > 0) _layer1HasData = true;
          for (const c of convos) {
            if (c.status != null) {
              // è®°å½•å‘ç°çš„çŠ¶æ€å€¼ï¼ˆå«ç±»å‹ä¿¡æ¯ï¼‰
              const statusKey = typeof c.status + ':' + c.status;
              if (!_discoveredStatuses.has(statusKey)) {
                _discoveredStatuses.add(statusKey);
                const logLevel = localStorage.getItem('ag-better-log-level');
                if (logLevel === 'debug') {
                  console.log('[AG-Bridge] Discovered status value:', JSON.stringify(c.status), 'type:', typeof c.status);
                }
              }
              // æ•°å­—ç±»å‹ç›´æ¥æ£€æŸ¥
              if (typeof c.status === 'number' && NUMERIC_BUSY_STATUSES.has(c.status)) {
                busyIds.add(c.cascadeId);
                continue;
              }
              // å­—ç¬¦ä¸²ç±»å‹
              const s = String(c.status).toLowerCase();
              if (BUSY_STATUSES.includes(s)) {
                busyIds.add(c.cascadeId);
              }
            }
          }
        } catch (e) { /* ignore */ }

        // Layer 2: Check cascade context state
        // CDP è°ƒè¯•ç¡®è®¤ï¼šisGenerating/isStreaming åœ¨æ­¤ Cascade ç‰ˆæœ¬ä¸­å§‹ç»ˆä¸º undefined
        // å®é™…å¿™ç¢ŒæŒ‡æ ‡ï¼šst.isRunning (top-level bool) å’Œ cs.executorLoopStatus (1=idle, 2+=busy)
        try {
          const ctx = findCascadeContext();
          if (ctx && ctx.state) {
            const st = ctx.state;
            const cs = st.cascadeState || {};
            const cascadeId = cs.cascadeId;
            if (cascadeId) {
              const isBusy = (st.isRunning === true)
                || (st.isGenerating === true) || (st.isStreaming === true)
                || (cs.isGenerating === true) || (cs.isStreaming === true)
                || (typeof cs.executorLoopStatus === 'number' && cs.executorLoopStatus > 1);
              if (isBusy) {
                busyIds.add(cascadeId);
                const logLevel = localStorage.getItem('ag-better-log-level');
                if (logLevel === 'debug') {
                  console.log('[AG-Bridge] Layer2 busy:', cascadeId.substring(0, 8),
                    'isRunning:', st.isRunning, 'execLoop:', cs.executorLoopStatus,
                    'isGen:', st.isGenerating, cs.isGenerating,
                    'isStr:', st.isStreaming, cs.isStreaming);
                }
              }
            }
          }
        } catch (e) { /* ignore */ }

        // Layer 3: DOM-based â€” ä»…ä½œä¸ºæœ€åé˜²çº¿ï¼Œä¸”ä¸è¦†ç›– Layer 1 çš„åˆ¤æ–­
        // åªåœ¨ Layer 1 æ— æ•°æ®æ—¶å¯ç”¨ï¼Œä¸”åªåŒ¹é…é«˜ç½®ä¿¡åº¦çš„ stop/cancel æŒ‰é’®
        try {
          const currentId = getCurrentCascadeId();
          // ä»…å½“ Layer 1 æ²¡æœ‰è¯¥å¯¹è¯çš„æ•°æ®æ—¶æ‰ç”¨ DOM æ£€æµ‹
          // å¦‚æœ Layer 1 å·²ç»æŠ¥å‘Šäº†çŠ¶æ€ï¼ˆåŒ…æ‹¬ idleï¼‰ï¼Œä¿¡ä»» Layer 1
          if (currentId && !busyIds.has(currentId) && !_layer1HasData) {
            const selectors = [
              // ä»…ä¿ç•™ stop/cancel æŒ‰é’® â€” å”¯ä¸€å¯é çš„ç”Ÿæˆä¸­ DOM æŒ‡æ ‡
              // è¿™äº›æŒ‰é’®åªåœ¨ AI ç”ŸæˆæœŸé—´å­˜åœ¨ï¼Œå®Œæˆåç«‹å³ä» DOM ç§»é™¤
              '[data-testid="stop-button"]',
              'button[aria-label="Stop"]',
              'button[aria-label="Cancel"]',
              '.stop-button',
              '.codicon-debug-stop'
              // å·²ç§»é™¤ï¼š.animate-pulse, [class*="streaming"], [class*="generating"],
              // [class*="typing"], .in-progress-checkbox â€” è¿™äº›åŒ¹é… Cascade å¸¸é©» UI å…ƒç´ ï¼Œ
              // å¯¼è‡´ç©ºé—²å¯¹è¯è¢«è¯¯åˆ¤ä¸ºå¿™ç¢Œ
            ];
            const searchRoot = document.getElementById('react-app') || document.body;
            const found = searchRoot.querySelector(selectors.join(','));
            if (found && !found.closest('#ag-tab-bar') && found.offsetHeight > 0) {
              busyIds.add(currentId);
              if (!_discoveredStatuses.has('__dom_detected__')) {
                const logLevel = localStorage.getItem('ag-better-log-level');
                if (logLevel === 'debug') {
                  console.log('[AG-Bridge] DOM busy detected via:', found.tagName, found.className.substring(0, 80));
                }
                _discoveredStatuses.add('__dom_detected__');
              }
            }
          }
        } catch (e) { /* ignore */ }

        return busyIds;
      }

      // è·å–å·¥ä½œåŒºæ ‡è¯†ï¼Œç”¨äºéš”ç¦»ä¸åŒé¡¹ç›®çš„ Tab æ•°æ®
      function getWorkspaceId() {
        try {
          const parentTitle = window.parent.document.title || '';
          // æ ¼å¼: "WorkspaceName â€” filename" æˆ– "WorkspaceName"
          const dashIdx = parentTitle.indexOf(' \u2014 ');
          const ws = dashIdx > 0 ? parentTitle.substring(0, dashIdx).trim() : parentTitle.trim();
          if (ws.length > 0) return ws;
        } catch (e) { /* cross-origin or no parent */ }
        return 'default';
      }

      // è¯Šæ–­å‡½æ•°ï¼šè¾“å‡ºä¸‰å±‚å¿™ç¢Œæ£€æµ‹çš„å®æ—¶çŠ¶æ€
      function diagnoseBusy() {
        const result = { layers: {} };
        try {
          const convos = findConversationList();
          result.layers.layer1 = convos.map(function(c) {
            return {
              id: c.cascadeId ? c.cascadeId.substring(0, 8) : null,
              status: c.status,
              statusType: typeof c.status
            };
          });
        } catch (e) { result.layers.layer1 = { error: e.message }; }
        try {
          const ctx = findCascadeContext();
          if (ctx && ctx.state) {
            var cs = ctx.state.cascadeState || {};
            var st = ctx.state;
            result.layers.layer2 = {
              cascadeId: cs.cascadeId,
              status: cs.status,
              executorLoopStatus: cs.executorLoopStatus,
              isRunning: st.isRunning,
              isGenerating: st.isGenerating || cs.isGenerating,
              isStreaming: st.isStreaming || cs.isStreaming,
              wouldTrigger: (st.isRunning === true)
                || (st.isGenerating === true) || (st.isStreaming === true)
                || (cs.isGenerating === true) || (cs.isStreaming === true)
                || (typeof cs.executorLoopStatus === 'number' && cs.executorLoopStatus > 1)
            };
          }
        } catch (e) { result.layers.layer2 = { error: e.message }; }
        try {
          var selectors = [
            '[data-testid="stop-button"]', 'button[aria-label="Stop"]',
            'button[aria-label="Cancel"]', '.stop-button', '.codicon-debug-stop'
          ];
          var searchRoot = document.getElementById('react-app') || document.body;
          var found = searchRoot.querySelector(selectors.join(','));
          result.layers.layer3 = {
            found: !!found,
            element: found ? found.tagName + '.' + found.className.substring(0, 60) : null
          };
        } catch (e) { result.layers.layer3 = { error: e.message }; }
        result.busyIds = Array.from(getBusyConversations());
        return result;
      }

      // Expose bridge API on window for TabManager to use
      window._agBridge = {
        findCascadeContext: findCascadeContext,
        findConversationList: findConversationList,
        findConversationTitle: findConversationTitle,
        getCurrentCascadeId: getCurrentCascadeId,
        switchConversation: switchConversation,
        startNewConversation: startNewConversation,
        getBusyConversations: getBusyConversations,
        getWorkspaceId: getWorkspaceId,
        diagnoseBusy: diagnoseBusy,
        isReady: function() { return !!findCascadeContext(); }
      };

    } catch (e) {
      // Bridge init failed - tab switching will be unavailable but IDE works fine
    }
  })();
  </script>
  <style>
    /* ===== è‡ªå®šä¹‰é¢œè‰²å˜é‡ ===== */
    :root {
      --color-user-message: #60A5FA;
      --color-ai-response: #E0E0E0;
      --color-code-block: #A78BFA;
      --color-action-status: #4ADE80;
      --color-thinking: #9CA3AF;
      /* å­—ä½“å¤§å°å˜é‡ */
      --fontsize-user-message: 14px;
      --fontsize-ai-response: 14px;
      --fontsize-code-block: 13px;
      --fontsize-action-status: 13px;
      --fontsize-thinking: 13px;
      --bg-modal: #1e1e1e;
      --border-color: #3c3c3c;
      --accent-color: #667eea;
      --text-main: #fff;
      --text-sub: #999;
    }

    /* ===== Tab Bar æ ·å¼ ===== */
    .ag-tab-bar-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #e8e8e8;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      z-index: 1000;
      padding: 0 4px;
      height: 36px;
      overflow: hidden;
    }
    .ag-add-tab-btn {
      flex: 0 0 32px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: #555;
      cursor: pointer;
      border-radius: 4px;
      margin-right: 4px;
      transition: all 0.2s;
    }
    .ag-add-tab-btn:hover {
      background: rgba(0, 0, 0, 0.08);
      color: #222;
    }
    /* Tab è®¡æ•°å™¨ï¼šæ˜¾ç¤ºåœ¨ + æŒ‰é’®å³ä¾§ */
    .ag-tab-counter {
      flex: 0 0 auto;
      font-size: 11px;
      color: #888;
      margin-right: 4px;
      user-select: none;
      white-space: nowrap;
    }
    /* Tab æ æç¤º toastï¼ˆå›ºå®šå®šä½åœ¨ tab bar ä¸‹æ–¹ï¼‰ */
    .ag-tab-toast {
      position: fixed;
      left: 50%;
      top: 40px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.78);
      color: #fff;
      font-size: 12px;
      padding: 4px 12px;
      border-radius: 4px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.25s;
      z-index: 1001;
    }
    .ag-tab-toast.ag-toast-visible {
      opacity: 1;
    }
    .ag-tabs-scroll {
      flex: 1;
      display: flex;
      gap: 4px;
      overflow-x: auto;
      scrollbar-width: none;
      padding: 4px 0;
    }
    .ag-tabs-scroll::-webkit-scrollbar { display: none; }
    .ag-tab-item {
      position: relative;
      flex: 0 0 auto;
      height: 28px;
      padding: 0 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: #d5d5d5;
      border: 1px solid #bbb;
      border-radius: 4px;
      color: #444;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
      max-width: 160px;
      transition: all 0.2s;
    }
    .ag-tab-item:hover {
      background: #c8c8c8;
      color: #111;
    }
    .ag-tab-item.active {
      background: #f0f0f0;
      border-color: #667eea;
      color: #111;
    }
    .ag-tab-item span {
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .ag-tab-close {
      font-size: 14px;
      color: #666;
      opacity: 0.6;
      margin-right: -4px;
      transition: opacity 0.2s;
    }
    .ag-tab-close:hover { opacity: 1; color: #222; }
    .ag-tab-item[data-stale] { opacity: 0.5; }
    .ag-tab-item[data-stale] span:first-child { font-style: italic; color: #999; }
    .ag-tab-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #999;
      flex-shrink: 0;
    }
    .ag-tab-dot.active-dot {
      background: #4ADE80;
    }
    /* Scroll arrows for tab overflow */
    .ag-scroll-btn {
      flex: 0 0 24px;
      height: 28px;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(to right, #e0e0e0, #e8e8e8);
      border: none;
      color: #555;
      cursor: pointer;
      font-size: 14px;
      padding: 0;
      transition: color 0.15s, background 0.15s;
      user-select: none;
    }
    .ag-scroll-btn:last-child { background: linear-gradient(to left, #e0e0e0, #e8e8e8); }
    .ag-scroll-btn:hover { color: #111; background: #d0d0d0; }
    .ag-scroll-btn.visible { display: flex; }
    .ag-scroll-btn.at-edge { opacity: 0.3; cursor: default; }
    @keyframes ag-tab-shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-3px); }
      40% { transform: translateX(3px); }
      60% { transform: translateX(-2px); }
      80% { transform: translateX(2px); }
    }
    .ag-tab-item.shake { animation: ag-tab-shake 0.4s ease-in-out; }
    .ag-tab-rename-input {
      border: none;
      background: transparent;
      font: inherit;
      color: inherit;
      padding: 0;
      margin: 0;
      outline: none;
      min-width: 40px;
      max-width: 140px;
    }
    body.ag-tab-bar-active .react-app-container {
      margin-top: 36px;
      height: calc(100% - 36px) !important;
    }

    /* ===== æ‚¬æµ®æŒ‰é’®æ ·å¼ ===== */
    #settings-toggle-btn {
      position: fixed;
      right: 0;
      top: 66%;
      transform: translateY(-50%);
      width: 28px;
      height: 48px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 9999;
      transition: all 0.3s ease;
    }

    #settings-toggle-btn:hover {
      width: 36px;
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }

    #settings-toggle-btn svg {
      width: 18px;
      height: 18px;
      fill: white;
      transition: transform 0.3s ease;
    }

    #settings-toggle-btn:hover svg {
      transform: rotate(90deg);
    }

    /* ===== å¼¹çª—é®ç½©å±‚ ===== */
    #settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      align-items: center;
      justify-content: center;
    }

    #settings-overlay.show {
      display: flex;
    }

    #settings-overlay.visible {
      opacity: 1;
    }

    /* ===== è®¾ç½®å¼¹çª— ===== */
    #settings-modal {
      background: var(--bg-modal);
      border-radius: 12px;
      width: 400px;
      max-width: 90%;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid var(--border-color);
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      overflow: hidden;
    }

    #settings-overlay.visible #settings-modal {
      transform: scale(1);
    }

    /* å¼¹çª— Header */
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.02);
    }

    .header-left {
      display: flex;
      flex-direction: column;
    }

    .brand-name {
      color: var(--text-main);
      font-size: 16px;
      font-weight: 700;
      background: linear-gradient(90deg, #fff, #a5b4fc);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .brand-links {
      display: flex;
      gap: 12px;
      margin-top: 4px;
    }

    .brand-link {
      color: var(--text-sub);
      font-size: 10px;
      text-decoration: none;
      transition: color 0.2s;
    }

    .brand-link:hover {
      color: var(--accent-color);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .lang-switch {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-sub);
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .lang-switch:hover {
      border-color: var(--text-main);
      color: var(--text-main);
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-sub);
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      transition: color 0.2s;
    }

    .modal-close:hover {
      color: var(--text-main);
    }

    /* é€‰é¡¹å¡å¯¼èˆª */
    .tab-nav {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      padding: 0 10px;
      background: rgba(0, 0, 0, 0.1);
    }

    .tab-btn {
      flex: 1;
      background: none;
      border: none;
      color: var(--text-sub);
      padding: 12px;
      font-size: 13px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-main);
    }

    .tab-btn.active {
      color: var(--accent-color);
      font-weight: 600;
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--accent-color);
    }

    /* å†…å®¹åŒºåŸŸ */
    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 0;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.2s ease;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* æ‰‹é£ç´æ•ˆæœ */
    .accordion-item {
      border-bottom: 1px solid var(--border-color);
    }

    .accordion-header {
      padding: 14px 20px;
      background: rgba(255, 255, 255, 0.01);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }

    .accordion-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .accordion-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-main);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .accordion-icon {
      font-size: 10px;
      color: var(--text-sub);
      transition: transform 0.3s;
    }

    .accordion-item.expanded .accordion-icon {
      transform: rotate(180deg);
    }

    .accordion-body {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0, 1, 0, 1);
      background: rgba(0, 0, 0, 0.1);
    }

    .accordion-item.expanded .accordion-body {
      max-height: 1000px;
      /* è¶³å¤Ÿå¤§çš„å€¼ */
      transition: max-height 0.3s ease-in-out;
    }

    .accordion-inner {
      padding: 16px 20px;
    }

    /* é€šç”¨æ§ä»¶æ ·å¼ */
    .main-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: rgba(102, 126, 234, 0.1);
      border: 1px solid rgba(102, 126, 234, 0.2);
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .main-toggle-label {
      color: var(--text-main);
      font-size: 13px;
      font-weight: 500;
    }

    .setting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .setting-item:last-child {
      border-bottom: none;
    }

    .setting-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .setting-icon {
      font-size: 15px;
      width: 20px;
      text-align: center;
      color: var(--text-sub);
    }

    .setting-name {
      color: #ccc;
      font-size: 13px;
    }

    .setting-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 32px;
      height: 18px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #3c3c3c;
      transition: 0.3s;
      border-radius: 20px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 12px;
      width: 12px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked+.toggle-slider {
      background: var(--accent-color);
    }

    .toggle-switch input:checked+.toggle-slider:before {
      transform: translateX(14px);
    }

    /* Color Input */
    .color-input {
      width: 24px;
      height: 24px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
      background: none;
    }

    .color-input::-webkit-color-swatch-wrapper {
      padding: 2px;
    }

    .color-input::-webkit-color-swatch {
      border-radius: 2px;
      border: none;
    }

    /* Select Input */
    .select-input {
      background: #2d2d2d;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 8px;
      color: #ccc;
      font-size: 12px;
      cursor: pointer;
      outline: none;
      min-width: 110px;
    }

    .select-input:focus {
      border-color: var(--accent-color);
    }

    /* ===== é¢œè‰²è¦†ç›–æ ·å¼ ===== */
    /* ç”¨æˆ·æ¶ˆæ¯ */
    #react-app.color-user-message .bg-gray-500\/15 .whitespace-pre-wrap,
    #react-app.color-user-message .bg-gray-500\/15 [style*="word-break"] {
      color: var(--color-user-message) !important;
    }

    /* AIå›å¤ (æ’é™¤æ€è€ƒ) */
    #react-app.color-ai-response .prose:not(.opacity-70) p,
    #react-app.color-ai-response .prose:not(.opacity-70) li,
    #react-app.color-ai-response .prose:not(.opacity-70) h2,
    #react-app.color-ai-response .prose:not(.opacity-70) h3,
    #react-app.color-ai-response .prose:not(.opacity-70) strong,
    #react-app.color-ai-response .prose:not(.opacity-70) ul,
    #react-app.color-ai-response .prose:not(.opacity-70) ol,
    #react-app.color-ai-response .prose:not(.opacity-70) table,
    #react-app.color-ai-response .prose:not(.opacity-70) th,
    #react-app.color-ai-response .prose:not(.opacity-70) td {
      color: var(--color-ai-response) !important;
    }

    /* ä»£ç å— */
    #react-app.color-code-block pre,
    #react-app.color-code-block pre code,
    #react-app.color-code-block .code-block,
    #react-app.color-code-block .code-line {
      color: var(--color-code-block) !important;
    }

    /* æ“ä½œçŠ¶æ€ */
    #react-app.color-action-status .shrink-0:is(:contains('Analyzed'), :contains('Created'), :contains('Edited')),
    #react-app.color-action-status [class*="animate-fade-in"] .truncate {
      color: var(--color-action-status) !important;
    }

    /* æ€è€ƒè¿‡ç¨‹ */
    #react-app.color-thinking .opacity-70.prose,
    #react-app.color-thinking .opacity-70.prose * {
      color: var(--color-thinking) !important;
    }

    /* ===== å­—ä½“å¤§å°è¦†ç›–æ ·å¼ ===== */
    /* ç”¨æˆ·æ¶ˆæ¯å­—ä½“å¤§å° */
    #react-app.fontsize-user-message .bg-gray-500\/15 .whitespace-pre-wrap,
    #react-app.fontsize-user-message .bg-gray-500\/15 [style*="word-break"] {
      font-size: var(--fontsize-user-message) !important;
    }

    /* AIå›å¤å­—ä½“å¤§å° */
    #react-app.fontsize-ai-response .prose:not(.opacity-70) p,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) li,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) h2,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) h3,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) strong,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) ul,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) ol,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) table,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) th,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) td {
      font-size: var(--fontsize-ai-response) !important;
    }

    /* ä»£ç å—å­—ä½“å¤§å° */
    #react-app.fontsize-code-block pre,
    #react-app.fontsize-code-block pre code,
    #react-app.fontsize-code-block .code-block,
    #react-app.fontsize-code-block .code-line {
      font-size: var(--fontsize-code-block) !important;
    }

    /* æ“ä½œçŠ¶æ€å­—ä½“å¤§å° */
    #react-app.fontsize-action-status .shrink-0:is(:contains('Analyzed'), :contains('Created'), :contains('Edited')),
    #react-app.fontsize-action-status [class*="animate-fade-in"] .truncate {
      font-size: var(--fontsize-action-status) !important;
    }

    /* æ€è€ƒè¿‡ç¨‹å­—ä½“å¤§å° */
    #react-app.fontsize-thinking .opacity-70.prose,
    #react-app.fontsize-thinking .opacity-70.prose * {
      font-size: var(--fontsize-thinking) !important;
    }

    /* ===== å¤åˆ¶æŒ‰é’®æ ·å¼ ===== */
    .copy-btn {
      position: absolute;
      top: 6px;
      right: 26px;
      width: 26px;
      height: 26px;
      background: rgba(60, 60, 60, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
      z-index: 10;
    }

    .copy-btn svg {
      width: 14px;
      height: 14px;
      fill: #ccc;
    }

    .copy-btn:hover {
      background: rgba(102, 126, 234, 0.8);
      border-color: rgba(102, 126, 234, 0.5);
    }

    .copy-btn:hover svg {
      fill: #fff;
    }

    .copy-btn.copied {
      background: rgba(74, 222, 128, 0.8);
    }

    .copy-btn.copied svg {
      fill: #fff;
    }

    .copy-target {
      position: relative;
    }

    .copy-target:hover .copy-btn {
      opacity: 1;
    }

    /* ===== Toast æç¤ºæ ·å¼ ===== */
    #retry-toast {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 13px;
      z-index: 20000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease, top 0.3s ease;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #retry-toast.show {
      display: flex;
      opacity: 1;
      top: 60px;
    }

    #retry-toast.success {
      background: rgba(46, 125, 50, 0.9);
      border-color: rgba(76, 175, 80, 0.3);
    }

    .toast-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* ===== è‡ªåŠ¨æ“ä½œåŠŸèƒ½æ ·å¼ ===== */
    /* æŒ‰é’®ç±»å‹ Grid */
    .pattern-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 12px 0;
    }

    .pattern-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
      color: #ccc;
    }

    .pattern-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .pattern-item.active {
      border-color: var(--accent-color);
      background: rgba(102, 126, 234, 0.15);
      color: var(--text-main);
    }

    .pattern-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    /* ç»Ÿè®¡é¢æ¿ */
    .stats-panel {
      display: flex;
      justify-content: space-around;
      padding: 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      margin-top: 12px;
    }

    .stat-item {
      text-align: center;
      flex: 1;
    }

    .stat-icon {
      font-size: 16px;
      display: block;
      margin-bottom: 4px;
    }

    .stat-value {
      display: block;
      font-size: 18px;
      font-weight: 700;
      color: var(--text-main);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-sub);
      text-transform: uppercase;
    }

    /* å±é™©å‘½ä»¤è¾“å…¥æ¡† */
    .banned-textarea {
      width: 100%;
      min-height: 100px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: #ccc;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 11px;
      padding: 10px;
      resize: vertical;
      outline: none;
      box-sizing: border-box;
    }

    .banned-textarea:focus {
      border-color: var(--accent-color);
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .btn-action {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn-action.primary {
      background: var(--accent-color);
      color: white;
    }

    .btn-action.primary:hover {
      filter: brightness(1.1);
    }

    .btn-action.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #ccc;
      border: 1px solid var(--border-color);
    }

    .btn-action.secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .save-status {
      font-size: 11px;
      text-align: center;
      margin-top: 8px;
      min-height: 16px;
      color: #4ADE80;
    }

    /* ===== LaTeX å…¬å¼æ¸²æŸ“æ ·å¼ ===== */
    /* å—çº§å…¬å¼å±…ä¸­ */
    .latex-block {
      display: block;
      text-align: center;
      margin: 1em 0;
      overflow-x: auto;
    }

    /* é”™è¯¯æç¤ºæ ·å¼ */
    .latex-error {
      color: #f87171;
      font-size: 12px;
      background: rgba(248, 113, 113, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }

    .setting-desc {
      font-size: 11px;
      color: var(--text-sub);
      margin-bottom: 12px;
      line-height: 1.5;
    }

    /* å­—ä½“å¤§å°è¾“å…¥æ¡† */
    .fontsize-input {
      width: 50px;
      background: #2d2d2d;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 6px;
      color: #ccc;
      font-size: 12px;
      text-align: center;
      outline: none;
    }

    .fontsize-input:focus {
      border-color: var(--accent-color);
    }

    /* åŒæ­¥æŒ‰é’® */
    .sync-btn {
      background: rgba(102, 126, 234, 0.2);
      border: 1px solid var(--accent-color);
      border-radius: 4px;
      color: var(--accent-color);
      font-size: 11px;
      padding: 3px 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 6px;
    }

    .sync-btn:hover {
      background: var(--accent-color);
      color: #fff;
    }

    /* ç‰ˆæœ¬å·æ ‡ç­¾ */
    .version-tag {
      font-size: 10px;
      color: var(--text-sub);
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
      font-weight: normal;
    }

    /* æ›´æ–°æç¤ºæ¡ */
    .update-banner {
      display: none;
      background: linear-gradient(90deg, rgba(74, 222, 128, 0.15), rgba(102, 126, 234, 0.15));
      border: 1px solid rgba(74, 222, 128, 0.3);
      border-radius: 6px;
      padding: 8px 12px;
      margin-top: 10px;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      animation: fadeIn 0.3s ease;
    }

    .update-banner.show {
      display: flex;
    }

    .update-text {
      font-size: 12px;
      color: #4ADE80;
    }

    .update-text span {
      font-weight: 600;
    }

    .update-version {
      background: rgba(74, 222, 128, 0.3);
      padding: 1px 6px;
      border-radius: 4px;
      margin-left: 4px;
    }

    .update-close {
      background: none;
      border: none;
      color: rgba(74, 222, 128, 0.6);
      font-size: 16px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
      transition: color 0.2s;
    }

    .update-close:hover {
      color: #4ADE80;
    }

    .update-btn {
      background: #4ADE80;
      color: #1e1e1e;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }

    .update-btn:hover {
      background: #22c55e;
    }
  </style>
</head>

<body style="margin: 0">
  <div id="react-app" class="react-app-container"></div>

  <div id="retry-toast">
    <div class="toast-spinner"></div>
    <span id="retry-toast-text"></span>
  </div>

  <!-- æ‚¬æµ®è®¾ç½®æŒ‰é’® -->
  <button id="settings-toggle-btn" title="Open Settings">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M19.14,12.94c0.04-0.31,0.06-0.63,0.06-0.94c0-0.31-0.02-0.63-0.06-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.37,4.8,11.69,4.8,12s0.02,0.63,0.06,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z" />
    </svg>
  </button>

  <!-- è®¾ç½®å¼¹çª— -->
  <div id="settings-overlay">
    <div id="settings-modal">
      <!-- Header -->
      <div class="modal-header">
        <div class="header-left">
          <span class="brand-name">Antigravity Better<span class="version-tag" id="current-version"></span></span>
          <div class="brand-links">
            <a href="https://dpit.lib00.com" target="_blank" class="brand-link">ğŸŒ dpit.lib00.com</a>
            <a href="https://github.com/016/Antigravity-Better" target="_blank" class="brand-link">ğŸ“¦ GitHub</a>
          </div>
          <!-- æ›´æ–°æç¤ºæ¡ -->
          <div class="update-banner" id="update-banner">
            <span class="update-text">ğŸ‰ <span data-i18n="update_available">æ–°ç‰ˆæœ¬å¯ç”¨</span> <span id="new-version"
                class="update-version"></span></span>
            <span>
              <a href="https://github.com/016/Antigravity-Better/releases" target="_blank" class="update-btn"
                data-i18n="btn_download">ä¸‹è½½æ›´æ–°</a>
              <button class="update-close" id="update-close-btn" title="Close">&times;</button>
            </span>
          </div>
        </div>
        <div class="header-right">
          <button class="lang-switch" id="lang-switch">ğŸŒ En/ä¸­</button>
          <button class="modal-close" id="modal-close-btn">&times;</button>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="appearance" data-i18n="tab_appearance">ğŸ¨ å¤–è§‚</button>
        <button class="tab-btn" data-tab="features" data-i18n="tab_features">ğŸ› ï¸ åŠŸèƒ½</button>
        <button class="tab-btn" data-tab="system" data-i18n="tab_system">âš™ï¸ ç³»ç»Ÿ</button>
      </div>

      <!-- Content -->
      <div class="modal-body">
        <!-- Tab: Appearance -->
        <div class="tab-content active" id="tab-appearance">
          <!-- Accordion: Colors -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="colors_title">ğŸ¨ é¢œè‰²è‡ªå®šä¹‰</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_custom_colors">å¯ç”¨è‡ªå®šä¹‰é¢œè‰²</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="color-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ“</span>
                      <span class="setting-name" data-i18n="lbl_user_msg">ç”¨æˆ·æ¶ˆæ¯</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-user-message" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-user-message" class="color-input" value="#60A5FA">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ¤–</span>
                      <span class="setting-name" data-i18n="lbl_ai_resp">AIå›å¤</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-ai-response" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-ai-response" class="color-input" value="#E0E0E0">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’»</span>
                      <span class="setting-name" data-i18n="lbl_code">ä»£ç å—</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-code-block" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-code-block" class="color-input" value="#A78BFA">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">âœ…</span>
                      <span class="setting-name" data-i18n="lbl_status">æ“ä½œçŠ¶æ€</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-action-status">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-action-status" class="color-input" value="#4ADE80">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’­</span>
                      <span class="setting-name" data-i18n="lbl_thinking">æ€è€ƒè¿‡ç¨‹</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-thinking">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-thinking" class="color-input" value="#9CA3AF">
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: Font Size -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="fontsize_title">ğŸ”¤ å­—ä½“å¤§å°</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_custom_fontsize">å¯ç”¨è‡ªå®šä¹‰å­—ä½“å¤§å°</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="fontsize-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="fontsize-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ“</span>
                      <span class="setting-name" data-i18n="lbl_user_msg">ç”¨æˆ·æ¶ˆæ¯</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-user-message" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-user-message" class="fontsize-input" value="14" min="10"
                        max="24"> px
                      <button id="fontsize-sync-btn" class="sync-btn" data-i18n="btn_sync">åŒæ­¥å…¨éƒ¨</button>
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ¤–</span>
                      <span class="setting-name" data-i18n="lbl_ai_resp">AIå›å¤</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-ai-response" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-ai-response" class="fontsize-input" value="14" min="10"
                        max="24"> px
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’»</span>
                      <span class="setting-name" data-i18n="lbl_code">ä»£ç å—</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-code-block" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-code-block" class="fontsize-input" value="13" min="10" max="24">
                      px
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">âœ…</span>
                      <span class="setting-name" data-i18n="lbl_status">æ“ä½œçŠ¶æ€</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-action-status">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-action-status" class="fontsize-input" value="13" min="10"
                        max="24"> px
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’­</span>
                      <span class="setting-name" data-i18n="lbl_thinking">æ€è€ƒè¿‡ç¨‹</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-thinking">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-thinking" class="fontsize-input" value="13" min="10" max="24">
                      px
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: LaTeX -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="latex_title">ğŸ“ LaTeX å…¬å¼</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_latex">å¯ç”¨ LaTeX æ¸²æŸ“</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="latex-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>
                <div class="setting-desc" data-i18n="latex_desc">è‡ªåŠ¨æ¸²æŸ“ AI å›å¤ä¸­çš„ LaTeX æ•°å­¦å…¬å¼</div>
                <div id="latex-status" class="save-status"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Tab: Features -->
        <div class="tab-content" id="tab-features">
          <!-- Accordion: Copy -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="copy_title">ğŸ“‹ ä¸€é”®å¤åˆ¶</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_copy">å¯ç”¨å¤åˆ¶æŒ‰é’®</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="copy-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="copy-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ“</span>
                      <span class="setting-name" data-i18n="lbl_user_msg">ç”¨æˆ·æ¶ˆæ¯</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-copy-user" checked>
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                  </div>
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’­</span>
                      <span class="setting-name" data-i18n="lbl_thinking">æ€è€ƒè¿‡ç¨‹</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-copy-thinking" checked>
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                  </div>
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ¤–</span>
                      <span class="setting-name" data-i18n="lbl_ai_resp">AIå›å¤</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-copy-ai" checked>
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: Hotkeys -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="hotkey_title">âŒ¨ï¸ å¿«æ·é”®è®¾ç½®</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_hotkey">è‡ªå®šä¹‰å‘é€å¿«æ·é”®</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="hotkey-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="hotkey-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">â†µ</span>
                      <span class="setting-name" data-i18n="lbl_send_hotkey">å‘é€å¿«æ·é”®</span>
                    </div>
                    <div class="setting-right">
                      <select id="send-hotkey-select" class="select-input">
                        <option value="enter">Enter</option>
                        <option value="cmd+enter">âŒ˜ Cmd + Enter</option>
                        <option value="ctrl+enter">Ctrl + Enter</option>
                        <option value="shift+enter">â‡§ Shift + Enter</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>


          <!-- Accordion: Auto Accept -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="auto_accept_title">ğŸ¤– è‡ªåŠ¨æ“ä½œ</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_auto_accept">å¯ç”¨è‡ªåŠ¨æ“ä½œ</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="auto-accept-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div class="setting-desc" data-i18n="auto_accept_desc">é€‰æ‹©è¦è‡ªåŠ¨ç‚¹å‡»çš„æŒ‰é’®ç±»å‹</div>

                <div id="auto-accept-patterns" class="pattern-grid">
                  <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>

                <!-- ç»Ÿè®¡é¢æ¿ -->
                <div id="auto-accept-stats" class="stats-panel">
                  <div class="stat-item">
                    <span class="stat-icon">âœ…</span>
                    <span class="stat-value" id="stat-clicks">0</span>
                    <span class="stat-label" data-i18n="stat_clicks">å·²ç‚¹å‡»</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-icon">ğŸ›¡ï¸</span>
                    <span class="stat-value" id="stat-blocked">0</span>
                    <span class="stat-label" data-i18n="stat_blocked">å·²é˜»æ­¢</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-icon">âœ“</span>
                    <span class="stat-value" id="stat-verified">0</span>
                    <span class="stat-label" data-i18n="stat_verified">å·²éªŒè¯</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: Safety Rules -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="banned_title">ğŸ›¡ï¸ å®‰å…¨è§„åˆ™</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="setting-desc" data-i18n="banned_desc">åŒ…å«ä»¥ä¸‹å…³é”®è¯çš„å‘½ä»¤å°†ä¸ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</div>
                <textarea id="banned-commands-input" class="banned-textarea" rows="6"></textarea>
                <div class="btn-group">
                  <button id="save-banned-btn" class="btn-action primary" data-i18n="btn_save">ä¿å­˜</button>
                  <button id="reset-banned-btn" class="btn-action secondary" data-i18n="btn_reset">é‡ç½®</button>
                </div>
                <div id="banned-save-status" class="save-status"></div>
              </div>
            </div>
          </div>
        </div>

          <!-- Accordion: Tab Bar -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="tab_bar_title">ğŸ“‘ æ¨ªå‘ Tab æ </span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_tab_bar">å¯ç”¨ Tab æ </span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="tab-bar-master-toggle" checked>
                    <span class="toggle-slider"></span>
                  </label>
                </div>
                <div class="setting-desc" data-i18n="tab_bar_desc">åœ¨é¡¶éƒ¨æ˜¾ç¤ºæ¨ªå‘æ ‡ç­¾æ ï¼Œå¿«é€Ÿåˆ‡æ¢å¤šä¸ªå¯¹è¯</div>

                <div class="setting-item">
                  <div class="setting-info">
                    <span class="setting-name" data-i18n="tab_bar_max_tabs">æœ€å¤§ Tab æ•°é‡</span>
                  </div>
                  <div class="setting-control">
                    <select class="select-input" id="tab-bar-max-tabs">
                      <option value="5">5</option>
                      <option value="8">8</option>
                      <option value="10" selected>10</option>
                      <option value="15">15</option>
                      <option value="20">20</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Tab: System -->
        <div class="tab-content" id="tab-system">
          <!-- Accordion: Version Update -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="version_title">ğŸ”„ ç‰ˆæœ¬æ›´æ–°</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="setting-item">
                  <div class="setting-left">
                    <span class="setting-icon">ğŸ”„</span>
                    <span class="setting-name" data-i18n="lbl_auto_update">å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹</span>
                  </div>
                  <div class="setting-right">
                    <label class="toggle-switch">
                      <input type="checkbox" id="auto-update-toggle" checked>
                      <span class="toggle-slider"></span>
                    </label>
                  </div>
                </div>

                <div class="setting-item">
                  <div class="setting-left">
                    <span class="setting-icon">ğŸ‘‰</span>
                    <span class="setting-name" data-i18n="lbl_manual_update">æ‰‹åŠ¨æ£€æµ‹æ›´æ–°</span>
                  </div>
                  <div class="setting-right">
                    <button id="manual-update-btn" class="btn-action primary" data-i18n="btn_check_update">ç«‹å³æ£€æµ‹</button>
                  </div>
                </div>

                <div id="update-status" class="save-status"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== I18N å­—å…¸ ===== */
    const TRANSLATIONS = {
      zh: {
        tab_appearance: 'ğŸ¨ å¤–è§‚',
        tab_features: 'ğŸ› ï¸ åŠŸèƒ½',
        colors_title: 'ğŸ¨ é¢œè‰²è‡ªå®šä¹‰',
        enable_custom_colors: 'å¯ç”¨è‡ªå®šä¹‰é¢œè‰²',
        lbl_user_msg: 'ç”¨æˆ·æ¶ˆæ¯',
        lbl_ai_resp: 'AIå›å¤',
        lbl_code: 'ä»£ç å—',
        lbl_status: 'æ“ä½œçŠ¶æ€',
        lbl_thinking: 'æ€è€ƒè¿‡ç¨‹',
        fontsize_title: 'ğŸ”¤ å­—ä½“å¤§å°',
        enable_custom_fontsize: 'å¯ç”¨è‡ªå®šä¹‰å­—ä½“å¤§å°',
        btn_sync: 'åŒæ­¥å…¨éƒ¨',
        update_available: 'æ–°ç‰ˆæœ¬å¯ç”¨',
        btn_download: 'ä¸‹è½½æ›´æ–°',
        copy_title: 'ğŸ“‹ ä¸€é”®å¤åˆ¶',
        enable_copy: 'å¯ç”¨å¤åˆ¶æŒ‰é’®',
        hotkey_title: 'âŒ¨ï¸ å¿«æ·é”®è®¾ç½®',
        enable_hotkey: 'è‡ªå®šä¹‰å‘é€å¿«æ·é”®',
        lbl_send_hotkey: 'å‘é€å¿«æ·é”®',
        auto_accept_title: 'ğŸ¤– è‡ªåŠ¨æ“ä½œ',
        enable_auto_accept: 'å¯ç”¨è‡ªåŠ¨æ“ä½œ',
        auto_accept_desc: 'é€‰æ‹©è¦è‡ªåŠ¨ç‚¹å‡»çš„æŒ‰é’®ç±»å‹',
        stat_clicks: 'å·²ç‚¹å‡»',
        stat_blocked: 'å·²é˜»æ­¢',
        stat_verified: 'å·²éªŒè¯',
        banned_title: 'ğŸ›¡ï¸ å®‰å…¨è§„åˆ™',
        banned_desc: 'åŒ…å«ä»¥ä¸‹å…³é”®è¯çš„å‘½ä»¤å°†ä¸ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰',
        btn_save: 'ä¿å­˜',
        btn_reset: 'é‡ç½®',
        banned_saved: 'âœ“ å®‰å…¨è§„åˆ™å·²ä¿å­˜',
        banned_reset: 'âœ“ å·²é‡ç½®ä¸ºé»˜è®¤å€¼',
        tab_system: 'âš™ï¸ ç³»ç»Ÿ',
        version_title: 'ğŸ”„ ç‰ˆæœ¬æ›´æ–°',
        lbl_auto_update: 'å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹',
        lbl_manual_update: 'æ‰‹åŠ¨æ£€æµ‹æ›´æ–°',
        btn_check_update: 'ç«‹å³æ£€æµ‹',
        update_checking: 'æ­£åœ¨æ£€æµ‹...',
        update_latest: 'âœ“ å·²æ˜¯æœ€æ–°ç‰ˆæœ¬',
        update_found: 'âœ“ å‘ç°æ–°ç‰ˆæœ¬',
        update_failed: 'âœ— æ£€æµ‹å¤±è´¥',
        latex_title: 'ğŸ“ LaTeX å…¬å¼',
        enable_latex: 'å¯ç”¨ LaTeX æ¸²æŸ“',
        latex_desc: 'è‡ªåŠ¨æ¸²æŸ“ AI å›å¤ä¸­çš„ LaTeX æ•°å­¦å…¬å¼',
        latex_loading: 'åŠ è½½ KaTeX åº“... cdn.jsdelivr.net',
        latex_ready: 'âœ“ KaTeX å·²å°±ç»ª',
        latex_failed: 'âœ— KaTeX åŠ è½½å¤±è´¥',
        tab_bar_title: 'ğŸ“‘ æ¨ªå‘ Tab æ ',
        enable_tab_bar: 'å¯ç”¨ Tab æ ',
        tab_bar_desc: 'åœ¨é¡¶éƒ¨æ˜¾ç¤ºæ¨ªå‘æ ‡ç­¾æ ï¼Œå¿«é€Ÿåˆ‡æ¢å¤šä¸ªå¯¹è¯',
        tab_bar_max_tabs: 'æœ€å¤§ Tab æ•°é‡'
      },
      en: {
        tab_appearance: 'ğŸ¨ Appearance',
        tab_features: 'ğŸ› ï¸ Features',
        colors_title: 'ğŸ¨ Colors',
        enable_custom_colors: 'Enable Custom Colors',
        lbl_user_msg: 'User Message',
        lbl_ai_resp: 'AI Response',
        lbl_code: 'Code Block',
        lbl_status: 'Action Status',
        lbl_thinking: 'Thinking Process',
        fontsize_title: 'ğŸ”¤ Font Size',
        enable_custom_fontsize: 'Enable Custom Font Size',
        btn_sync: 'Sync All',
        update_available: 'New version available',
        btn_download: 'Download',
        copy_title: 'ğŸ“‹ One-Click Copy',
        enable_copy: 'Enable Copy Buttons',
        hotkey_title: 'âŒ¨ï¸ Shortcuts',
        enable_hotkey: 'Custom Send Hotkey',
        lbl_send_hotkey: 'Send Hotkey',
        auto_accept_title: 'ğŸ¤– Auto Accept',
        enable_auto_accept: 'Enable Auto Accept',
        auto_accept_desc: 'Select button types to auto-click',
        stat_clicks: 'Clicked',
        stat_blocked: 'Blocked',
        stat_verified: 'Verified',
        banned_title: 'ğŸ›¡ï¸ Safety Rules',
        banned_desc: 'Commands containing these keywords will not be auto-executed (one per line)',
        btn_save: 'Save',
        btn_reset: 'Reset',
        banned_saved: 'âœ“ Safety rules saved',
        banned_reset: 'âœ“ Reset to defaults',
        tab_system: 'âš™ï¸ System',
        version_title: 'ğŸ”„ Version Update',
        lbl_auto_update: 'Auto check on startup',
        lbl_manual_update: 'Manual check',
        btn_check_update: 'Check Now',
        update_checking: 'Checking...',
        update_latest: 'âœ“ Already latest',
        update_found: 'âœ“ New version found',
        update_failed: 'âœ— Check failed',
        latex_title: 'ğŸ“ LaTeX Formulas',
        enable_latex: 'Enable LaTeX Rendering',
        latex_desc: 'Auto-render LaTeX math formulas in AI responses',
        latex_loading: 'Loading KaTeX... cdn.jsdelivr.net',
        latex_ready: 'âœ“ KaTeX Ready',
        latex_failed: 'âœ— KaTeX Load Failed',
        tab_bar_title: 'ğŸ“‘ Tab Bar',
        enable_tab_bar: 'Enable Tab Bar',
        tab_bar_desc: 'Show horizontal tab bar at top for quick conversation switching',
        tab_bar_max_tabs: 'Max Tabs'
      }
    };

    /* ===== ç‰ˆæœ¬æ£€æµ‹é…ç½® ===== */
    const APP_VERSION = '0.1.7';
    const VERSION_API = 'https://hub.lib00.com/api/v1/antigravity-better/version';

    // è¯­ä¹‰åŒ–ç‰ˆæœ¬æ¯”è¾ƒï¼šremote > local è¿”å› true
    function isNewerVersion(remote, local) {
      const r = remote.replace(/^v/i, '').split('.').map(Number);
      const l = local.replace(/^v/i, '').split('.').map(Number);
      for (let i = 0; i < Math.max(r.length, l.length); i++) {
        if ((r[i] || 0) > (l[i] || 0)) return true;
        if ((r[i] || 0) < (l[i] || 0)) return false;
      }
      return false;
    }

    // æ˜¾ç¤ºæ›´æ–°æç¤º
    function showUpdateBanner(newVersion, downloadUrl) {
      const banner = document.getElementById('update-banner');
      const versionSpan = document.getElementById('new-version');
      const downloadBtn = banner ? banner.querySelector('.update-btn') : null;
      if (banner && versionSpan) {
        versionSpan.textContent = 'v' + newVersion;
        if (downloadUrl && downloadBtn) downloadBtn.href = downloadUrl;
        banner.classList.add('show');
      }
    }

    // éšè—æ›´æ–°æç¤º
    function hideUpdateBanner() {
      const banner = document.getElementById('update-banner');
      if (banner) banner.classList.remove('show');
    }

    // ç»‘å®šå…³é—­æŒ‰é’®äº‹ä»¶
    document.getElementById('update-close-btn').addEventListener('click', hideUpdateBanner);

    // æ£€æµ‹æ›´æ–° (è¿”å›: 'found' | 'latest' | 'error')
    async function checkForUpdate() {
      try {
        const response = await fetch(VERSION_API, { cache: 'no-store' });
        if (!response.ok) return 'error';
        const json = await response.json();
        const data = json.data || json; // æ”¯æŒ { data: {...} } æˆ–ç›´æ¥ {...}
        const remoteVersion = data.version;
        if (remoteVersion && isNewerVersion(remoteVersion, APP_VERSION)) {
          showUpdateBanner(remoteVersion, data.url);
          return 'found';
        }
        return 'latest';
      } catch (e) {
        console.log('[VersionCheck] Failed:', e.message);
        return 'error';
      }
    }

    // æ‰‹åŠ¨æ£€æµ‹æ›´æ–° (å¸¦ UI åé¦ˆ)
    async function manualCheckUpdate() {
      const statusEl = document.getElementById('update-status');
      const btn = document.getElementById('manual-update-btn');
      const dict = TRANSLATIONS[currentSettings.lang];

      if (statusEl) statusEl.textContent = dict.update_checking;
      if (btn) btn.disabled = true;

      const result = await checkForUpdate();

      if (statusEl) {
        if (result === 'found') statusEl.textContent = dict.update_found;
        else if (result === 'latest') statusEl.textContent = dict.update_latest;
        else statusEl.textContent = dict.update_failed;
        setTimeout(() => { statusEl.textContent = ''; }, 3000);
      }
      if (btn) btn.disabled = false;
    }

    /* ===== æ—¢å­˜é…ç½®é€»è¾‘ ===== */
    const STORAGE_KEY = 'cascade-panel-settings';

    // é¢œè‰²é…ç½®
    const COLOR_CONFIGS = [
      { id: 'user-message', cssVar: '--color-user-message', cssClass: 'color-user-message', default: '#60A5FA', enabled: true },
      { id: 'ai-response', cssVar: '--color-ai-response', cssClass: 'color-ai-response', default: '#E0E0E0', enabled: true },
      { id: 'code-block', cssVar: '--color-code-block', cssClass: 'color-code-block', default: '#A78BFA', enabled: true },
      { id: 'action-status', cssVar: '--color-action-status', cssClass: 'color-action-status', default: '#4ADE80', enabled: false },
      { id: 'thinking', cssVar: '--color-thinking', cssClass: 'color-thinking', default: '#9CA3AF', enabled: false },
    ];

    // å­—ä½“å¤§å°é…ç½®
    const FONTSIZE_CONFIGS = [
      { id: 'user-message', cssVar: '--fontsize-user-message', cssClass: 'fontsize-user-message', default: 14, enabled: true },
      { id: 'ai-response', cssVar: '--fontsize-ai-response', cssClass: 'fontsize-ai-response', default: 14, enabled: true },
      { id: 'code-block', cssVar: '--fontsize-code-block', cssClass: 'fontsize-code-block', default: 13, enabled: true },
      { id: 'action-status', cssVar: '--fontsize-action-status', cssClass: 'fontsize-action-status', default: 13, enabled: false },
      { id: 'thinking', cssVar: '--fontsize-thinking', cssClass: 'fontsize-thinking', default: 13, enabled: false },
    ];

    // å¤åˆ¶é…ç½®
    const COPY_CONFIGS = [
      { id: 'copy-user', selector: '.bg-gray-500\\/15', textSelector: '.whitespace-pre-wrap', type: 'user' },
      { id: 'copy-thinking', selector: '.opacity-70.prose', textSelector: null, type: 'thinking' },
      { id: 'copy-ai', selector: '.prose:not(.opacity-70)', textSelector: null, type: 'ai' },
    ];

    // å¿«æ·é”®é€‰é¡¹
    const HOTKEY_OPTIONS = [
      { id: 'enter', label: 'Enter', check: (e) => e.key === 'Enter' && !e.metaKey && !e.ctrlKey && !e.shiftKey },
      { id: 'cmd+enter', label: 'âŒ˜ Cmd + Enter', check: (e) => e.key === 'Enter' && e.metaKey },
      { id: 'ctrl+enter', label: 'Ctrl + Enter', check: (e) => e.key === 'Enter' && e.ctrlKey },
      { id: 'shift+enter', label: 'â‡§ Shift + Enter', check: (e) => e.key === 'Enter' && e.shiftKey },
    ];

    // è‡ªåŠ¨æ“ä½œæŒ‰é’®é…ç½® - æ¯ä¸ªç±»å‹å¯ç‹¬ç«‹å¼€å…³
    const AUTO_ACCEPT_CONFIGS = [
      { id: 'accept', label: 'Accept', defaultEnabled: false },
      { id: 'retry', label: 'Retry', defaultEnabled: true },
      { id: 'run', label: 'Run', defaultEnabled: true },
      { id: 'apply', label: 'Apply', defaultEnabled: true },
      { id: 'execute', label: 'Execute', defaultEnabled: true },
      { id: 'confirm', label: 'Confirm', defaultEnabled: true },
      { id: 'allow', label: 'Allow', defaultEnabled: true },
    ];

    // å±é™©å‘½ä»¤é»˜è®¤é»‘åå•
    const DEFAULT_BANNED_COMMANDS = [
      'rm -rf /',
      'rm -rf ~',
      'rm -rf *',
      'format c:',
      'del /f /s /q',
      'rmdir /s /q',
      ':(){:|:&};:',
      'dd if=',
      'mkfs.',
      '> /dev/sda',
      'chmod -R 777 /'
    ];

    const defaultSettings = {
      lang: 'zh',
      masterEnabled: false,
      colors: COLOR_CONFIGS.reduce((acc, c) => { acc[c.id] = { color: c.default, enabled: c.enabled }; return acc; }, {}),
      // å­—ä½“å¤§å°è®¾ç½®
      fontsizeMasterEnabled: false,
      fontsizes: FONTSIZE_CONFIGS.reduce((acc, c) => { acc[c.id] = { size: c.default, enabled: c.enabled }; return acc; }, {}),
      copyEnabled: false,
      copy: COPY_CONFIGS.reduce((acc, c) => { acc[c.id] = { enabled: true }; return acc; }, {}),
      hotkeyEnabled: false,
      sendHotkey: 'cmd+enter',
      // è‡ªåŠ¨æ“ä½œé…ç½®
      autoAcceptEnabled: false,
      autoAcceptPatterns: AUTO_ACCEPT_CONFIGS.reduce((acc, c) => { acc[c.id] = c.defaultEnabled; return acc; }, {}),
      bannedCommands: [...DEFAULT_BANNED_COMMANDS],
      // ç»Ÿè®¡æ•°æ®
      autoAcceptStats: { clicks: 0, blocked: 0, verified: 0 },
      // ç³»ç»Ÿè®¾ç½®
      autoUpdateEnabled: true,
      // LaTeX æ¸²æŸ“è®¾ç½®
      latexEnabled: false,
      // Tab Bar è®¾ç½®
      tabBarEnabled: true,
      tabBarMaxTabs: 10
    };

    function loadSettings() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          return {
            lang: parsed.lang ?? defaultSettings.lang,
            masterEnabled: parsed.masterEnabled ?? defaultSettings.masterEnabled,
            colors: { ...defaultSettings.colors, ...parsed.colors },
            fontsizeMasterEnabled: parsed.fontsizeMasterEnabled ?? defaultSettings.fontsizeMasterEnabled,
            fontsizes: { ...defaultSettings.fontsizes, ...parsed.fontsizes },
            copyEnabled: parsed.copyEnabled ?? defaultSettings.copyEnabled,
            copy: { ...defaultSettings.copy, ...parsed.copy },
            hotkeyEnabled: parsed.hotkeyEnabled ?? defaultSettings.hotkeyEnabled,
            sendHotkey: parsed.sendHotkey ?? defaultSettings.sendHotkey,
            // è‡ªåŠ¨æ“ä½œé…ç½®
            autoAcceptEnabled: parsed.autoAcceptEnabled ?? defaultSettings.autoAcceptEnabled,
            autoAcceptPatterns: { ...defaultSettings.autoAcceptPatterns, ...parsed.autoAcceptPatterns },
            bannedCommands: parsed.bannedCommands ?? [...DEFAULT_BANNED_COMMANDS],
            autoAcceptStats: { ...defaultSettings.autoAcceptStats, ...parsed.autoAcceptStats },
            autoUpdateEnabled: parsed.autoUpdateEnabled ?? defaultSettings.autoUpdateEnabled,
            latexEnabled: parsed.latexEnabled ?? defaultSettings.latexEnabled,
            tabBarEnabled: parsed.tabBarEnabled ?? defaultSettings.tabBarEnabled,
            tabBarMaxTabs: parsed.tabBarMaxTabs ?? defaultSettings.tabBarMaxTabs
          };
        }
        return { ...defaultSettings };
      } catch (e) { return { ...defaultSettings }; }
    }

    function saveSettings(settings) {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch (e) { console.warn('Save failed:', e); }
    }

    /* ===== DOM å…ƒç´  ===== */
    const settingsBtn = document.getElementById('settings-toggle-btn');
    const overlay = document.getElementById('settings-overlay');
    const closeBtn = document.getElementById('modal-close-btn');
    const langSwitch = document.getElementById('lang-switch');
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    const accordionHeaders = document.querySelectorAll('.accordion-header');

    // æ§ä»¶å¼•ç”¨
    const masterToggle = document.getElementById('master-toggle');
    const copyMasterToggle = document.getElementById('copy-master-toggle');
    const hotkeyMasterToggle = document.getElementById('hotkey-master-toggle');
    const fontsizeMasterToggle = document.getElementById('fontsize-master-toggle');
    const sendHotkeySelect = document.getElementById('send-hotkey-select');
    const reactApp = document.getElementById('react-app');

    // è‡ªåŠ¨æ“ä½œæ§ä»¶å¼•ç”¨
    const autoAcceptMasterToggle = document.getElementById('auto-accept-master-toggle');
    const autoAcceptPatternsContainer = document.getElementById('auto-accept-patterns');
    const bannedCommandsInput = document.getElementById('banned-commands-input');
    const saveBannedBtn = document.getElementById('save-banned-btn');
    const resetBannedBtn = document.getElementById('reset-banned-btn');
    const bannedSaveStatus = document.getElementById('banned-save-status');
    const statClicksEl = document.getElementById('stat-clicks');
    const statBlockedEl = document.getElementById('stat-blocked');
    const statVerifiedEl = document.getElementById('stat-verified');

    // LaTeX æ§ä»¶å¼•ç”¨
    const latexMasterToggle = document.getElementById('latex-master-toggle');
    const latexStatusEl = document.getElementById('latex-status');

    /* ===== äº¤äº’é€»è¾‘ ===== */
    let currentSettings = loadSettings();

    // 1. è¯­è¨€åˆ‡æ¢
    function updateLanguage() {
      const lang = currentSettings.lang;
      const dict = TRANSLATIONS[lang];
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (dict[key]) el.textContent = dict[key];
      });
      langSwitch.textContent = lang === 'zh' ? 'ğŸŒ English' : 'ğŸŒ ä¸­æ–‡';
    }

    langSwitch.addEventListener('click', () => {
      currentSettings.lang = currentSettings.lang === 'zh' ? 'en' : 'zh';
      saveSettings(currentSettings);
      updateLanguage();
    });

    // 2. Tab åˆ‡æ¢
    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        tabBtns.forEach(b => b.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));

        btn.classList.add('active');
        const tabId = `tab-${btn.dataset.tab}`;
        document.getElementById(tabId).classList.add('active');
      });
    });

    // 3. æ‰‹é£ç´é€»è¾‘
    accordionHeaders.forEach(header => {
      header.addEventListener('click', () => {
        const item = header.parentElement;
        item.classList.toggle('expanded');
      });
    });

    // 4. å¼¹çª—æ§åˆ¶
    function openModal() {
      overlay.classList.add('show');
      requestAnimationFrame(() => overlay.classList.add('visible'));
    }
    function closeModal() {
      overlay.classList.remove('visible');
      setTimeout(() => overlay.classList.remove('show'), 300);
    }
    settingsBtn.addEventListener('click', openModal);
    closeBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });

    /* ===== åŠŸèƒ½å®ç° ===== */
    // A. é¢œè‰²åŠŸèƒ½
    function applyColorSettings() {
      COLOR_CONFIGS.forEach(config => {
        const colorSetting = currentSettings.colors[config.id];
        document.documentElement.style.setProperty(config.cssVar, colorSetting.color);
        if (currentSettings.masterEnabled && colorSetting.enabled) {
          reactApp.classList.add(config.cssClass);
        } else {
          reactApp.classList.remove(config.cssClass);
        }
      });
    }

    masterToggle.addEventListener('change', () => {
      currentSettings.masterEnabled = masterToggle.checked;
      saveSettings(currentSettings);
      applyColorSettings();
    });

    COLOR_CONFIGS.forEach(config => {
      const toggleEl = document.getElementById(`toggle-${config.id}`);
      const colorEl = document.getElementById(`color-${config.id}`);

      if (toggleEl) {
        toggleEl.addEventListener('change', () => {
          currentSettings.colors[config.id].enabled = toggleEl.checked;
          saveSettings(currentSettings);
          applyColorSettings();
        });
      }
      if (colorEl) {
        colorEl.addEventListener('input', () => {
          currentSettings.colors[config.id].color = colorEl.value;
          saveSettings(currentSettings);
          applyColorSettings();
        });
      }
    });

    // A2. å­—ä½“å¤§å°åŠŸèƒ½
    function applyFontsizeSettings() {
      FONTSIZE_CONFIGS.forEach(config => {
        const fontSetting = currentSettings.fontsizes[config.id];
        document.documentElement.style.setProperty(config.cssVar, fontSetting.size + 'px');
        if (currentSettings.fontsizeMasterEnabled && fontSetting.enabled) {
          reactApp.classList.add(config.cssClass);
        } else {
          reactApp.classList.remove(config.cssClass);
        }
      });
    }

    fontsizeMasterToggle.addEventListener('change', () => {
      currentSettings.fontsizeMasterEnabled = fontsizeMasterToggle.checked;
      saveSettings(currentSettings);
      applyFontsizeSettings();
    });

    FONTSIZE_CONFIGS.forEach(config => {
      const toggleEl = document.getElementById(`toggle-fontsize-${config.id}`);
      const sizeEl = document.getElementById(`fontsize-${config.id}`);

      if (toggleEl) {
        toggleEl.addEventListener('change', () => {
          currentSettings.fontsizes[config.id].enabled = toggleEl.checked;
          saveSettings(currentSettings);
          applyFontsizeSettings();
        });
      }
      if (sizeEl) {
        sizeEl.addEventListener('input', () => {
          const val = parseInt(sizeEl.value) || config.default;
          currentSettings.fontsizes[config.id].size = Math.max(10, Math.min(24, val));
          saveSettings(currentSettings);
          applyFontsizeSettings();
        });
      }
    });

    // ä¸€é”®åŒæ­¥å­—ä½“å¤§å°æŒ‰é’®
    document.getElementById('fontsize-sync-btn').addEventListener('click', () => {
      const baseSize = currentSettings.fontsizes['user-message'].size;
      FONTSIZE_CONFIGS.forEach(config => {
        currentSettings.fontsizes[config.id].size = baseSize;
        const sizeEl = document.getElementById(`fontsize-${config.id}`);
        if (sizeEl) sizeEl.value = baseSize;
      });
      saveSettings(currentSettings);
      applyFontsizeSettings();
    });

    // B. å¤åˆ¶åŠŸèƒ½
    let copyObserver = null;
    const COPY_ICON = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
    const CHECK_ICON = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';

    function copyToClipboard(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      let success = false;
      try { success = document.execCommand('copy'); } catch (err) { }
      document.body.removeChild(textarea);
      return success;
    }

    function createCopyButton(targetEl, getText) {
      const btn = document.createElement('button');
      btn.className = 'copy-btn';
      btn.innerHTML = COPY_ICON;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        const success = copyToClipboard(getText());
        if (success) {
          btn.innerHTML = CHECK_ICON;
          btn.classList.add('copied');
          setTimeout(() => {
            btn.innerHTML = COPY_ICON;
            btn.classList.remove('copied');
          }, 1500);
        }
      });
      return btn;
    }

    function injectCopyButtons() {
      if (!currentSettings.copyEnabled) return;
      COPY_CONFIGS.forEach(config => {
        if (!currentSettings.copy[config.id]?.enabled) return;
        const elements = reactApp.querySelectorAll(config.selector);
        elements.forEach(el => {
          if (el.querySelector('.copy-btn') || el.closest('#settings-overlay')) return;
          el.classList.add('copy-target');
          const getText = () => config.textSelector ? (el.querySelector(config.textSelector)?.textContent || el.textContent) : el.textContent;
          el.appendChild(createCopyButton(el, getText));
        });
      });
    }

    function removeCopyButtons() {
      reactApp.querySelectorAll('.copy-btn').forEach(btn => btn.remove());
      reactApp.querySelectorAll('.copy-target').forEach(el => el.classList.remove('copy-target'));
    }

    function applyCopySettings() {
      if (currentSettings.copyEnabled) {
        if (!copyObserver) {
          copyObserver = new MutationObserver(() => setTimeout(injectCopyButtons, 100));
          copyObserver.observe(reactApp, { childList: true, subtree: true });
          injectCopyButtons();
        }
      } else {
        if (copyObserver) { copyObserver.disconnect(); copyObserver = null; }
        removeCopyButtons();
      }
    }

    copyMasterToggle.addEventListener('change', () => {
      currentSettings.copyEnabled = copyMasterToggle.checked;
      saveSettings(currentSettings);
      applyCopySettings();
    });

    COPY_CONFIGS.forEach(config => {
      const toggleEl = document.getElementById(`toggle-${config.id}`);
      if (toggleEl) {
        toggleEl.addEventListener('change', () => {
          currentSettings.copy[config.id].enabled = toggleEl.checked;
          saveSettings(currentSettings);
          removeCopyButtons();
          if (currentSettings.copyEnabled) injectCopyButtons();
        });
      }
    });

    // C. å¿«æ·é”®åŠŸèƒ½
    let hotkeyHandler = null;
    const INPUT_SELECTOR = 'div[contenteditable="true"][data-lexical-editor="true"]';
    const SEND_BTN_SELECTOR = 'button[data-tooltip-id="input-send-button-send-tooltip"]';

    function createHotkeyHandler() {
      const selected = currentSettings.sendHotkey;
      const config = HOTKEY_OPTIONS.find(h => h.id === selected);
      return function (e) {
        const inputEl = e.target.closest(INPUT_SELECTOR);
        if (!inputEl || e.key !== 'Enter') return;

        // æ£€æŸ¥ä¸‹æ‹‰èœå•
        if (inputEl.hasAttribute('aria-activedescendant') ||
          (document.querySelector('.lexical-typeahead-menu') && document.querySelector('.lexical-typeahead-menu').style.display !== 'none')) {
          return;
        }

        if (config && config.check(e)) {
          e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
          const sendBtn = document.querySelector(SEND_BTN_SELECTOR);
          if (sendBtn) {
            sendBtn.click();
          }
        } else if (e.key === 'Enter') {
          // é˜»æ­¢é»˜è®¤å‘é€ (é™¤éshift+enter)
          if (!e.shiftKey || selected === 'shift+enter') {
            e.stopPropagation(); e.stopImmediatePropagation();
          }
        }
      };
    }

    function applyHotkeySettings() {
      if (hotkeyHandler) { document.removeEventListener('keydown', hotkeyHandler, { capture: true }); hotkeyHandler = null; }
      if (currentSettings.hotkeyEnabled) {
        hotkeyHandler = createHotkeyHandler();
        document.addEventListener('keydown', hotkeyHandler, { capture: true });
      }
    }

    hotkeyMasterToggle.addEventListener('change', () => {
      currentSettings.hotkeyEnabled = hotkeyMasterToggle.checked;
      saveSettings(currentSettings);
      applyHotkeySettings();
    });

    sendHotkeySelect.addEventListener('change', () => {
      currentSettings.sendHotkey = sendHotkeySelect.value;
      saveSettings(currentSettings);
      if (currentSettings.hotkeyEnabled) applyHotkeySettings();
    });


    /* ===== E. è‡ªåŠ¨æ“ä½œåŠŸèƒ½ ===== */
    let autoAcceptObserver = null;

    // æ›´æ–°ç»Ÿè®¡é¢æ¿
    function updateStatsUI() {
      if (statClicksEl) statClicksEl.textContent = currentSettings.autoAcceptStats.clicks;
      if (statBlockedEl) statBlockedEl.textContent = currentSettings.autoAcceptStats.blocked;
      if (statVerifiedEl) statVerifiedEl.textContent = currentSettings.autoAcceptStats.verified;
    }

    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    function updateStats(delta) {
      if (delta.clicks) currentSettings.autoAcceptStats.clicks += delta.clicks;
      if (delta.blocked) currentSettings.autoAcceptStats.blocked += delta.blocked;
      if (delta.verified) currentSettings.autoAcceptStats.verified += delta.verified;
      saveSettings(currentSettings);
      updateStatsUI();
    }

    // æ¸²æŸ“æŒ‰é’®ç±»å‹ checkbox
    function renderPatternCheckboxes() {
      if (!autoAcceptPatternsContainer) return;
      autoAcceptPatternsContainer.innerHTML = '';

      AUTO_ACCEPT_CONFIGS.forEach(config => {
        const isEnabled = currentSettings.autoAcceptPatterns[config.id];
        const label = document.createElement('label');
        label.className = `pattern-item${isEnabled ? ' active' : ''}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = isEnabled;
        checkbox.addEventListener('change', () => {
          currentSettings.autoAcceptPatterns[config.id] = checkbox.checked;
          label.classList.toggle('active', checkbox.checked);
          saveSettings(currentSettings);
        });

        const text = document.createElement('span');
        text.textContent = config.label;

        label.appendChild(checkbox);
        label.appendChild(text);
        autoAcceptPatternsContainer.appendChild(label);
      });
    }

    // åˆ¤æ–­æŒ‰é’®æ˜¯å¦ä¸ºè‡ªåŠ¨æ¥å—ç›®æ ‡
    function isAutoAcceptButton(el) {
      const text = (el.textContent || '').trim().toLowerCase();
      if (text.length === 0 || text.length > 50) return false;

      // è·å–å¯ç”¨çš„æŒ‰é’®æ¨¡å¼
      const patterns = Object.entries(currentSettings.autoAcceptPatterns)
        .filter(([_, enabled]) => enabled)
        .map(([pattern, _]) => pattern);

      if (patterns.length === 0) return false;

      // æ’é™¤è¯
      const rejects = ['skip', 'reject', 'cancel', 'close', 'refine', 'dismiss'];
      if (rejects.some(r => text.includes(r))) return false;

      // åŒ¹é…å¯ç”¨çš„æ¨¡å¼
      if (!patterns.some(p => text.includes(p))) return false;

      // æ£€æŸ¥å¯è§æ€§
      const style = window.getComputedStyle(el);
      const rect = el.getBoundingClientRect();
      return style.display !== 'none' && rect.width > 0 && !el.disabled;
    }

    // ä»æŒ‰é’®é™„è¿‘æå–å‘½ä»¤æ–‡æœ¬
    function findNearbyCommandText(buttonEl) {
      let commandText = '';
      let container = buttonEl.parentElement;
      let depth = 0;

      while (container && depth < 10) {
        let sibling = container.previousElementSibling;
        let siblingCount = 0;

        while (sibling && siblingCount < 5) {
          if (sibling.tagName === 'PRE' || sibling.tagName === 'CODE') {
            commandText += ' ' + sibling.textContent.trim();
          }
          const codeEls = sibling.querySelectorAll('pre, code');
          codeEls.forEach(el => {
            if (el.textContent) commandText += ' ' + el.textContent.trim();
          });
          sibling = sibling.previousElementSibling;
          siblingCount++;
        }

        if (commandText.length > 10) break;
        container = container.parentElement;
        depth++;
      }

      return commandText.trim().toLowerCase();
    }

    // æ£€æŸ¥å‘½ä»¤æ˜¯å¦åœ¨é»‘åå•ä¸­
    function isCommandBanned(commandText) {
      const bannedList = currentSettings.bannedCommands || [];
      if (!commandText || bannedList.length === 0) return false;

      const lowerText = commandText.toLowerCase();
      return bannedList.some(pattern => {
        if (!pattern) return false;
        return lowerText.includes(pattern.toLowerCase());
      });
    }

    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
    function isElementVisible(el) {
      if (!el || !el.isConnected) return false;
      const style = window.getComputedStyle(el);
      const rect = el.getBoundingClientRect();
      return style.display !== 'none' && rect.width > 0;
    }

    // ç­‰å¾…å…ƒç´ æ¶ˆå¤±ï¼ˆéªŒè¯ç‚¹å‡»æˆåŠŸï¼‰
    function waitForDisappear(el, timeout = 500) {
      return new Promise(resolve => {
        const startTime = Date.now();
        const check = () => {
          if (!isElementVisible(el)) {
            resolve(true);
          } else if (Date.now() - startTime >= timeout) {
            resolve(false);
          } else {
            requestAnimationFrame(check);
          }
        };
        setTimeout(check, 50);
      });
    }

    // æ‰§è¡Œè‡ªåŠ¨æ“ä½œ
    async function performAutoAccept() {
      if (!currentSettings.autoAcceptEnabled) return;

      const buttons = reactApp.querySelectorAll('button');

      for (const btn of buttons) {
        if (!isAutoAcceptButton(btn)) continue;

        const buttonText = (btn.textContent || '').trim().toLowerCase();

        // æ£€æŸ¥æ˜¯å¦ä¸ºå‘½ä»¤æ‰§è¡ŒæŒ‰é’®
        if (/run|execute/i.test(buttonText)) {
          const nearbyText = findNearbyCommandText(btn);
          if (isCommandBanned(nearbyText)) {
            console.log('[AutoAccept] Blocked dangerous command:', nearbyText.substring(0, 50));
            updateStats({ blocked: 1 });
            continue;
          }
        }

        // æ‰§è¡Œç‚¹å‡»
        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
        updateStats({ clicks: 1 });

        // éªŒè¯ç‚¹å‡»
        const disappeared = await waitForDisappear(btn);
        if (disappeared) {
          updateStats({ verified: 1 });
        }

        // é˜²æ­¢è¿ç»­ç‚¹å‡»å¤ªå¿«
        await new Promise(r => setTimeout(r, 100));
      }
    }

    // åº”ç”¨è‡ªåŠ¨æ“ä½œè®¾ç½®
    function applyAutoAcceptSettings() {
      if (autoAcceptObserver) {
        autoAcceptObserver.disconnect();
        autoAcceptObserver = null;
      }

      if (currentSettings.autoAcceptEnabled) {
        autoAcceptObserver = new MutationObserver(() => {
          clearTimeout(window.autoAcceptThrottleTimer);
          window.autoAcceptThrottleTimer = setTimeout(performAutoAccept, 500);
        });
        autoAcceptObserver.observe(reactApp, { childList: true, subtree: true });
        performAutoAccept(); // åˆå§‹æ‰§è¡Œä¸€æ¬¡
      }
    }

    // è‡ªåŠ¨æ“ä½œä¸»å¼€å…³äº‹ä»¶
    if (autoAcceptMasterToggle) {
      autoAcceptMasterToggle.addEventListener('change', () => {
        currentSettings.autoAcceptEnabled = autoAcceptMasterToggle.checked;
        saveSettings(currentSettings);
        applyAutoAcceptSettings();
      });
    }

    // å±é™©å‘½ä»¤ä¿å­˜æŒ‰é’®
    if (saveBannedBtn) {
      saveBannedBtn.addEventListener('click', () => {
        const lines = bannedCommandsInput.value.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        currentSettings.bannedCommands = lines;
        saveSettings(currentSettings);
        if (bannedSaveStatus) {
          bannedSaveStatus.textContent = TRANSLATIONS[currentSettings.lang].banned_saved;
          setTimeout(() => { bannedSaveStatus.textContent = ''; }, 3000);
        }
      });
    }

    // å±é™©å‘½ä»¤é‡ç½®æŒ‰é’®
    if (resetBannedBtn) {
      resetBannedBtn.addEventListener('click', () => {
        currentSettings.bannedCommands = [...DEFAULT_BANNED_COMMANDS];
        bannedCommandsInput.value = DEFAULT_BANNED_COMMANDS.join('\n');
        saveSettings(currentSettings);
        if (bannedSaveStatus) {
          bannedSaveStatus.textContent = TRANSLATIONS[currentSettings.lang].banned_reset;
          setTimeout(() => { bannedSaveStatus.textContent = ''; }, 3000);
        }
      });
    }

    /* ===== LaTeX æ¸²æŸ“åŠŸèƒ½ ===== */
    let katexLoaded = false;
    let katexLoading = false;
    let latexObserver = null;

    // KaTeX CDN èµ„æº
    const KATEX_CSS = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
    const KATEX_JS = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';

    // åŠ¨æ€åŠ è½½ KaTeX (ä»…åœ¨å¯ç”¨æ—¶åŠ è½½)
    function loadKaTeX() {
      return new Promise((resolve, reject) => {
        if (katexLoaded) { resolve(); return; }
        if (katexLoading) {
          // ç­‰å¾…åŠ è½½å®Œæˆ
          const check = setInterval(() => {
            if (katexLoaded) { clearInterval(check); resolve(); }
          }, 100);
          return;
        }

        katexLoading = true;
        const dict = TRANSLATIONS[currentSettings.lang];
        if (latexStatusEl) latexStatusEl.textContent = dict.latex_loading;

        // åŠ è½½ CSS
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = KATEX_CSS;
        document.head.appendChild(link);

        // åŠ è½½ JS
        const script = document.createElement('script');
        script.src = KATEX_JS;
        script.onload = () => {
          katexLoaded = true;
          katexLoading = false;
          if (latexStatusEl) latexStatusEl.textContent = dict.latex_ready;
          setTimeout(() => { if (latexStatusEl) latexStatusEl.textContent = ''; }, 2000);
          resolve();
        };
        script.onerror = () => {
          katexLoading = false;
          if (latexStatusEl) latexStatusEl.textContent = dict.latex_failed;
          reject(new Error('KaTeX load failed'));
        };
        document.head.appendChild(script);
      });
    }

    // æ¸²æŸ“å•ä¸ªå…¬å¼
    function renderLatex(formula, displayMode = false) {
      if (!window.katex) return null;
      try {
        return window.katex.renderToString(formula, {
          throwOnError: false,
          displayMode: displayMode
        });
      } catch (e) {
        return `<span class="latex-error">[LaTeX Error: ${e.message}]</span>`;
      }
    }

    // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹ä¸­çš„ LaTeX å…¬å¼
    function processLatexInText(textNode) {
      const text = textNode.textContent;
      // å—çº§å…¬å¼: $$...$$
      // è¡Œå†…å…¬å¼: $...$ (ä½†æ’é™¤ $$ å’Œå•ç‹¬çš„ $)
      const pattern = /(\$\$[\s\S]+?\$\$|\$(?!\$)(?:[^$\n]|\n(?!\n))+?\$(?!\$))/g;

      if (!pattern.test(text)) return false;
      pattern.lastIndex = 0;

      const fragment = document.createDocumentFragment();
      let lastIndex = 0;
      let match;

      while ((match = pattern.exec(text)) !== null) {
        // æ·»åŠ å…¬å¼å‰çš„æ™®é€šæ–‡æœ¬
        if (match.index > lastIndex) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
        }

        const fullMatch = match[0];
        const isBlock = fullMatch.startsWith('$$');
        const formula = isBlock ? fullMatch.slice(2, -2).trim() : fullMatch.slice(1, -1).trim();
        const rendered = renderLatex(formula, isBlock);

        if (rendered) {
          const wrapper = document.createElement(isBlock ? 'div' : 'span');
          wrapper.className = isBlock ? 'latex-block latex-rendered' : 'latex-rendered';
          // ä¿å­˜åŸå§‹å…¬å¼ç”¨äºè¿˜åŸ
          wrapper.dataset.latexOriginal = fullMatch;
          wrapper.innerHTML = rendered;
          fragment.appendChild(wrapper);
        } else {
          fragment.appendChild(document.createTextNode(fullMatch));
        }

        lastIndex = match.index + fullMatch.length;
      }

      // æ·»åŠ å‰©ä½™æ–‡æœ¬
      if (lastIndex < text.length) {
        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      textNode.parentNode.replaceChild(fragment, textNode);
      return true;
    }

    // æ‰«æå¹¶æ¸²æŸ“ LaTeX å…¬å¼
    function scanAndRenderLatex() {
      if (!currentSettings.latexEnabled || !katexLoaded) return;

      // åªå¤„ç† AI å›å¤åŒºåŸŸ (.prose)
      const proseElements = reactApp.querySelectorAll('.prose:not(.opacity-70)');

      proseElements.forEach(prose => {
        // è·³è¿‡å·²å¤„ç†çš„
        if (prose.dataset.latexProcessed) return;

        // è·å–æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
        const walker = document.createTreeWalker(prose, NodeFilter.SHOW_TEXT, null, false);
        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
          // è·³è¿‡ code/pre/script/style ä¸­çš„å†…å®¹
          const parent = node.parentNode;
          if (parent && /^(code|pre|script|style)$/i.test(parent.tagName)) continue;
          if (node.textContent.includes('$')) textNodes.push(node);
        }

        // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹ (å€’åºé¿å…ç´¢å¼•é—®é¢˜)
        let hasLatex = false;
        for (let i = textNodes.length - 1; i >= 0; i--) {
          if (processLatexInText(textNodes[i])) hasLatex = true;
        }

        if (hasLatex) prose.dataset.latexProcessed = 'true';
      });
    }

    // è¿˜åŸæ‰€æœ‰å·²æ¸²æŸ“çš„ LaTeX å…¬å¼ä¸ºåŸå§‹æ–‡æœ¬
    function revertLatex() {
      // æŸ¥æ‰¾æ‰€æœ‰å·²æ¸²æŸ“çš„å…¬å¼å…ƒç´ 
      const renderedElements = reactApp.querySelectorAll('.latex-rendered');

      renderedElements.forEach(el => {
        const original = el.dataset.latexOriginal;
        if (original) {
          const textNode = document.createTextNode(original);
          el.parentNode.replaceChild(textNode, el);
        }
      });

      // æ¸…é™¤å¤„ç†æ ‡è®°
      reactApp.querySelectorAll('[data-latex-processed]').forEach(el => {
        delete el.dataset.latexProcessed;
      });
    }

    // åº”ç”¨ LaTeX è®¾ç½®
    async function applyLatexSettings() {
      // é”€æ¯ç°æœ‰ observer
      if (latexObserver) {
        latexObserver.disconnect();
        latexObserver = null;
      }

      if (!currentSettings.latexEnabled) {
        // ç¦ç”¨æ—¶ç«‹å³è¿˜åŸå…¬å¼
        revertLatex();
        return;
      }

      // åŠ è½½ KaTeX å¹¶å¼€å§‹ç›‘å¬
      try {
        await loadKaTeX();

        // åˆ›å»º observer ç›‘å¬æ–°å†…å®¹
        latexObserver = new MutationObserver(() => {
          clearTimeout(window.latexThrottleTimer);
          window.latexThrottleTimer = setTimeout(scanAndRenderLatex, 300);
        });
        latexObserver.observe(reactApp, { childList: true, subtree: true });

        // ç«‹å³æ‰«æå½“å‰å†…å®¹
        scanAndRenderLatex();
      } catch (e) {
        console.warn('[LaTeX] Init failed:', e.message);
      }
    }

    // LaTeX å¼€å…³äº‹ä»¶
    if (latexMasterToggle) {
      latexMasterToggle.addEventListener('change', () => {
        currentSettings.latexEnabled = latexMasterToggle.checked;
        saveSettings(currentSettings);
        applyLatexSettings();
      });
    }

    /* ===== HistoryTabManager ===== */
    const TAB_STORAGE_KEY_GLOBAL = 'ag-better-tabs';
    const TAB_STORAGE_KEY_OLD = 'ag-better-tab-state';
    function getTabStorageKey() {
      const wsId = (window._agBridge && window._agBridge.getWorkspaceId)
        ? window._agBridge.getWorkspaceId() : 'default';
      return 'ag-better-tabs-' + wsId;
    }
    const LOG_LEVELS = { error: 0, warn: 1, info: 2, debug: 3 };

    class HistoryTabManager {
      constructor(maxTabs) {
        this._switchId = 0;
        this._state = 'idle'; // idle | switching | verifying | success | failed | cancelled
        this._tabs = [];
        this._activeTabId = null;
        this._maxTabs = maxTabs || 10;
        this._nextId = 1;
        this._container = null;
        this._scrollArea = null;
        this._bridgeReady = false;
        this._pollTimer = null;
        this._syncTimer = null;
        this._logLevel = LOG_LEVELS[localStorage.getItem('ag-better-log-level') || 'error'] ?? 0;
        this._destroyed = false;
      }

      // --- Logging ---
      _log(level, ...args) {
        if (LOG_LEVELS[level] > this._logLevel) return;
        const prefix = '[AG-TabBar]';
        if (level === 'error') console.error(prefix, ...args);
        else if (level === 'warn') console.warn(prefix, ...args);
        else if (level === 'info') console.info(prefix, ...args);
        else console.log(prefix, ...args);
      }

      // --- Initialization ---
      init() {
        this._createTabBarDOM();
        this._loadPersistedTabs();
        this._updateCounter(); // åˆå§‹åŒ–è®¡æ•°å™¨
        this._waitForBridge();
        document.body.classList.add('ag-tab-bar-active');
        this._log('info', 'Tab bar initialized');
      }

      _createTabBarDOM() {
        this._container = document.createElement('div');
        this._container.className = 'ag-tab-bar-container';

        // Add tab button
        const addBtn = document.createElement('button');
        addBtn.className = 'ag-add-tab-btn';
        addBtn.innerHTML = '+';
        addBtn.title = 'New conversation';
        addBtn.addEventListener('click', () => this._onAddTab());
        this._container.appendChild(addBtn);

        // Tab è®¡æ•°å™¨ï¼ˆ+ æŒ‰é’®å³ä¾§ï¼‰
        this._counterEl = document.createElement('span');
        this._counterEl.className = 'ag-tab-counter';
        this._container.appendChild(this._counterEl);

        // Left scroll arrow
        this._scrollLeftBtn = document.createElement('button');
        this._scrollLeftBtn.className = 'ag-scroll-btn';
        this._scrollLeftBtn.textContent = '\u25C0';
        this._scrollLeftBtn.addEventListener('click', () => {
          this._scrollArea.scrollBy({ left: -120, behavior: 'smooth' });
        });
        this._container.appendChild(this._scrollLeftBtn);

        // Scroll area for tabs
        this._scrollArea = document.createElement('div');
        this._scrollArea.className = 'ag-tabs-scroll';
        this._scrollArea.addEventListener('scroll', () => this._updateScrollArrows());
        this._container.appendChild(this._scrollArea);

        // Right scroll arrow
        this._scrollRightBtn = document.createElement('button');
        this._scrollRightBtn.className = 'ag-scroll-btn';
        this._scrollRightBtn.textContent = '\u25B6';
        this._scrollRightBtn.addEventListener('click', () => {
          this._scrollArea.scrollBy({ left: 120, behavior: 'smooth' });
        });
        this._container.appendChild(this._scrollRightBtn);

        document.body.prepend(this._container);

        // Toast æç¤ºå…ƒç´ ï¼ˆæ”¾åœ¨ body ä¸Šé¿å…è¢« container overflow:hidden è£åˆ‡ï¼‰
        this._toastEl = document.createElement('div');
        this._toastEl.className = 'ag-tab-toast';
        document.body.appendChild(this._toastEl);

        // ä½¿ tab bar å®¹å™¨å¯èšç„¦ï¼Œç”¨äºé”®ç›˜å¯¼èˆª
        this._container.setAttribute('tabindex', '0');
        // é”®ç›˜å¯¼èˆªäº‹ä»¶ï¼ˆä»…åœ¨ tab bar èšç„¦æ—¶ç”Ÿæ•ˆï¼‰
        this._keydownHandler = (e) => this._handleKeydown(e);
        this._container.addEventListener('keydown', this._keydownHandler);

        // Update arrows on window resize (panel width changes)
        this._resizeHandler = () => this._updateScrollArrows();
        window.addEventListener('resize', this._resizeHandler);
      }

      _updateScrollArrows() {
        if (!this._scrollArea || !this._scrollLeftBtn || !this._scrollRightBtn) return;
        // Use setTimeout to let layout settle after DOM changes and smooth scroll start
        setTimeout(() => {
          if (!this._scrollArea) return;
          const { scrollLeft, scrollWidth, clientWidth } = this._scrollArea;
          const overflows = scrollWidth > clientWidth + 1;
          // Show both arrows when tabs overflow
          this._scrollLeftBtn.classList.toggle('visible', overflows);
          this._scrollRightBtn.classList.toggle('visible', overflows);
          // Gray out at edges
          this._scrollLeftBtn.classList.toggle('at-edge', scrollLeft <= 1);
          this._scrollRightBtn.classList.toggle('at-edge', scrollLeft >= scrollWidth - clientWidth - 1);
        }, 80);
      }

      // --- Tab è®¡æ•°å™¨æ›´æ–° ---
      _updateCounter() {
        if (!this._counterEl) return;
        this._counterEl.textContent = '(' + this._tabs.length + ')';
      }

      // --- Toast æç¤ºï¼ˆçŸ­æš‚æ˜¾ç¤ºåè‡ªåŠ¨æ¶ˆå¤±ï¼‰ ---
      _showToast(msg) {
        if (!this._toastEl) return;
        // æ¸…é™¤å‰ä¸€ä¸ª toast å®šæ—¶å™¨
        if (this._toastTimer) {
          clearTimeout(this._toastTimer);
          this._toastTimer = null;
        }
        this._toastEl.textContent = msg;
        this._toastEl.classList.add('ag-toast-visible');
        this._toastTimer = setTimeout(() => {
          this._toastEl.classList.remove('ag-toast-visible');
          this._toastTimer = null;
        }, 2000);
      }

      // --- é”®ç›˜å¯¼èˆª ---
      _handleKeydown(e) {
        // å¿½ç•¥åœ¨è¾“å…¥æ¡†ä¸­çš„æŒ‰é”®
        const tag = e.target.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

        let direction = 0; // -1=å·¦, 1=å³
        if (e.key === 'ArrowLeft') direction = -1;
        else if (e.key === 'ArrowRight') direction = 1;
        else if (e.key === 'Tab') {
          direction = 1;
          e.preventDefault(); // é˜»æ­¢ç„¦ç‚¹è·³å‡º tab bar
        }
        if (direction === 0) return;

        e.preventDefault();
        const currentIdx = this._tabs.findIndex(t => t.id === this._activeTabId);
        if (currentIdx === -1) return;
        const targetIdx = currentIdx + direction;
        // ä¸å›ç»•ï¼šåˆ°è¾¾è¾¹ç•Œæ—¶åœæ­¢
        if (targetIdx < 0 || targetIdx >= this._tabs.length) return;
        this._onClickTab(this._tabs[targetIdx].id);
      }

      _waitForBridge() {
        const check = () => {
          if (this._destroyed) return;
          if (window._agBridge && window._agBridge.isReady()) {
            this._bridgeReady = true;
            this._log('info', 'Bridge ready');
            this._onBridgeReady();
          } else {
            this._pollTimer = setTimeout(check, 2000);
          }
        };
        check();
      }

      _onBridgeReady() {
        // Sync with current conversation
        const currentId = window._agBridge.getCurrentCascadeId();
        this._log('debug', 'Current cascade ID:', currentId);

        // æ¸…ç†ä¸å±äºå½“å‰å·¥ä½œåŒºçš„ stale Tab
        try {
          const convos = window._agBridge.findConversationList();
          const validIds = new Set(convos.map(function(c) { return c.cascadeId; }));
          const before = this._tabs.length;
          this._tabs = this._tabs.filter(function(t) {
            return !t.cascadeId || t.cascadeId === currentId || validIds.has(t.cascadeId);
          });
          if (this._tabs.length < before) {
            this._log('info', 'Cleaned', before - this._tabs.length, 'stale tabs');
          }
        } catch (e) {
          this._log('warn', 'Failed to clean stale tabs:', e.message);
        }

        if (this._tabs.length === 0) {
          // æ— æŒä¹…åŒ– Tab â€” ä¸ºå½“å‰å¯¹è¯åˆ›å»ºä¸€ä¸ª
          const title = this._getTitleForCascadeId(currentId) || (currentId ? ('Chat ' + currentId.substring(0, 8)) : 'New Chat');
          this._addTabInternal(title, currentId);
          // æ ‡é¢˜å¯èƒ½å°šæœªå°±ç»ªï¼Œ1.5s åé‡è¯•
          if (currentId && !this._getTitleForCascadeId(currentId)) {
            setTimeout(() => this.updateTabTitles(), 1500);
          }
        } else {
          // æŒä¹…åŒ– Tab å­˜åœ¨ â€” æŸ¥æ‰¾æˆ–åˆ›å»ºå½“å‰å¯¹è¯çš„ Tab
          const existingTab = currentId ? this._tabs.find(t => t.cascadeId === currentId) : null;
          if (existingTab) {
            this._activeTabId = existingTab.id;
          } else if (currentId) {
            // å½“å‰å¯¹è¯ä¸åœ¨ Tab ä¸­ â€” æ·»åŠ 
            const title = this._getTitleForCascadeId(currentId) || ('Chat ' + currentId.substring(0, 8));
            const newTab = this._addTabInternal(title, currentId);
            if (newTab) {
              // æ ‡é¢˜å¯èƒ½å°šæœªå°±ç»ªï¼Œ1.5s åé‡è¯•
              if (!this._getTitleForCascadeId(currentId)) {
                setTimeout(() => this.updateTabTitles(), 1500);
              }
            }
          } else if (this._tabs.length > 0) {
            // No current conversation - activate first tab
            this._activeTabId = this._tabs[0].id;
          }
        }

        this._renderTabs();
        this._saveTabs();

        // Start periodic sync to detect external conversation changes
        this._startSync();
      }

      _startSync() {
        if (this._syncTimer) clearInterval(this._syncTimer);
        this._syncTimer = setInterval(() => {
          if (this._destroyed || !this._bridgeReady || this._state === 'switching') return;
          const currentId = window._agBridge.getCurrentCascadeId();
          if (!currentId) {
            this._updateScrollArrows();
            this.updateTabTitles();
            this._updateBusyState();
            return;
          }

          const activeTab = this._tabs.find(t => t.id === this._activeTabId);
          if (activeTab && activeTab.cascadeId === currentId) {
            this._updateScrollArrows();
            this.updateTabTitles();
            this._updateBusyState();
            return;
          }

          // Active tab has no cascadeId (freshly created via "+") â€” bind it
          if (activeTab && !activeTab.cascadeId) {
            activeTab.cascadeId = currentId;
            const title = this._getTitleForCascadeId(currentId);
            if (title && !activeTab.customTitle) activeTab.title = title;
            this._renderTabs();
            this._saveTabs();
            this._log('debug', 'Bound cascadeId to active tab:', currentId);
            // Retry title fetch after a delay (summary may not be available yet)
            if (!title) {
              setTimeout(() => this.updateTabTitles(), 2000);
            }
            this._updateScrollArrows();
            this._updateBusyState();
            return;
          }

          // Current conversation changed externally
          const existingTab = this._tabs.find(t => t.cascadeId === currentId);
          if (existingTab) {
            this._activeTabId = existingTab.id;
            this._renderTabs();
            this._saveTabs();
            this._log('debug', 'Synced to externally switched conversation');
          } else {
            // å¤–éƒ¨æ‰“å¼€çš„æ–°å¯¹è¯ï¼ˆå« Past Conversation å¯¼å…¥ï¼‰â€” æ·»åŠ  Tab
            const title = this._getTitleForCascadeId(currentId) || 'New Chat';
            const newTab = this._addTabInternal(title, currentId);
            if (!newTab) {
              // Tab å·²æ»¡ï¼Œæ‹’ç»æ·»åŠ ï¼ˆtoast å·²åœ¨ _addTabInternal ä¸­æ˜¾ç¤ºï¼‰
              this._log('info', 'Rejected external conversation: tab limit reached');
              return;
            }
            this._renderTabs();
            this._saveTabs();
            this._log('debug', 'Added tab for externally opened conversation');
            // æ ‡é¢˜é‡è¯•ï¼šDOM æ ‡é¢˜å¯èƒ½éœ€è¦ç¨ç­‰ React æ¸²æŸ“å®Œæˆ
            setTimeout(() => this.updateTabTitles(), 800);
            setTimeout(() => this.updateTabTitles(), 2500);
          }
          this._updateBusyState();
          this._updateScrollArrows();
          this.updateTabTitles();
        }, 3000);

        // Faster polling for busy state (1s) â€” generation can be brief
        if (this._busyTimer) clearInterval(this._busyTimer);
        this._busyTimer = setInterval(() => {
          if (this._destroyed || !this._bridgeReady) return;
          this._updateBusyState();
        }, 1000);
      }

      _updateBusyState() {
        if (!window._agBridge || !window._agBridge.getBusyConversations) return;
        try {
          const busyIds = window._agBridge.getBusyConversations();
          let changed = false;
          for (const tab of this._tabs) {
            const isBusy = tab.cascadeId ? busyIds.has(tab.cascadeId) : false;
            const isActive = tab.id === this._activeTabId;

            if (isBusy && !tab.busy) {
              // Became busy â†’ mark activity unseen (only for non-active tabs)
              tab.busy = true;
              if (!isActive) {
                tab.activityUnseen = true;
              }
              console.log('[AG-TabMgr] Tab became busy:', tab.title.substring(0, 20),
                'cascadeId:', tab.cascadeId ? tab.cascadeId.substring(0, 8) : null,
                'isActive:', isActive, 'unseen:', tab.activityUnseen);
              changed = true;
            } else if (!isBusy && tab.busy) {
              // No longer busy
              tab.busy = false;
              if (isActive) {
                // Active tab: user is watching, clear unseen
                tab.activityUnseen = false;
              } else {
                // Inactive tab: user wasn't watching, mark unseen
                tab.activityUnseen = true;
              }
              changed = true;
            }

            // é˜²æŠ¤ï¼šæ´»è·ƒ Tab çš„ activityUnseen æ°¸è¿œä¸åº”ä¸º true
            // ç”¨æˆ·å·²åœ¨æŸ¥çœ‹æ­¤ Tabï¼Œæ— éœ€æç¤º"æœ‰æœªè¯»æ´»åŠ¨"
            if (isActive && tab.activityUnseen) {
              tab.activityUnseen = false;
              changed = true;
            }
          }
          if (changed) {
            this._renderTabs();
          }
        } catch (e) {
          this._log('warn', 'Busy state update failed:', e.message);
        }
      }

      _getTitleForCascadeId(cascadeId) {
        if (!cascadeId || !window._agBridge) return null;
        try {
          const title = window._agBridge.findConversationTitle(cascadeId);
          if (title) return title.substring(0, 40);
        } catch (e) {
          this._log('warn', 'Failed to get title:', e.message);
        }
        return null;
      }

      // --- Persistence ---
      _loadPersistedTabs() {
        try {
          const storageKey = getTabStorageKey();
          let raw = localStorage.getItem(storageKey);
          // è¿ç§»æ—§ key (ag-better-tab-state â†’ å·¥ä½œåŒº key)
          if (!raw) {
            raw = localStorage.getItem(TAB_STORAGE_KEY_OLD);
            if (raw) {
              localStorage.setItem(storageKey, raw);
              localStorage.removeItem(TAB_STORAGE_KEY_OLD);
              this._log('info', 'Migrated tab state from old key');
            }
          }
          // è¿ç§»å…¨å±€ key (ag-better-tabs â†’ å·¥ä½œåŒº key)
          if (!raw) {
            raw = localStorage.getItem(TAB_STORAGE_KEY_GLOBAL);
            if (raw) {
              localStorage.setItem(storageKey, raw);
              // ä¸åˆ é™¤å…¨å±€ keyï¼Œå…¶ä»–å·¥ä½œåŒºå¯èƒ½å°šæœªè¿ç§»
              this._log('info', 'Migrated tab state from global key to', storageKey);
            }
          }
          if (!raw) return;
          const data = JSON.parse(raw);
          if (data.version !== 1) return;
          this._tabs = (data.tabs || []).map(t => ({
            id: t.id,
            title: t.title || (t.cascadeId ? ('Chat ' + t.cascadeId.substring(0, 8)) : 'New Chat'),
            cascadeId: t.cascadeId || null,
            timestamp: t.timestamp || Date.now(),
            stale: false,
            customTitle: !!t.customTitle,
            busy: false,
            activityUnseen: false
          }));
          this._activeTabId = data.activeTabId || null;
          this._nextId = data.nextId || (this._tabs.length + 1);
          this._log('info', 'Loaded', this._tabs.length, 'persisted tabs');
        } catch (e) {
          this._log('warn', 'Failed to load persisted tabs:', e.message);
          this._tabs = [];
        }
      }

      _saveTabs() {
        try {
          const data = {
            version: 1,
            tabs: this._tabs.map(t => ({
              id: t.id,
              title: t.title,
              cascadeId: t.cascadeId,
              timestamp: t.timestamp,
              customTitle: !!t.customTitle
            })),
            activeTabId: this._activeTabId,
            nextId: this._nextId
          };
          localStorage.setItem(getTabStorageKey(), JSON.stringify(data));
        } catch (e) {
          this._log('error', 'Failed to save tabs:', e.message);
        }
      }

      // --- Tab Operations ---
      _addTabInternal(title, cascadeId) {
        // è¶…é™æ—¶æ‹’ç»æ·»åŠ ï¼Œè¿”å› null
        if (this._tabs.length >= this._maxTabs) {
          this._showToast('å·²è¾¾ä¸Šé™ï¼ˆ' + this._maxTabs + 'ï¼‰ï¼Œè¯·å…ˆå…³é—­æ ‡ç­¾');
          this._log('info', 'Tab limit reached, refusing add:', this._maxTabs);
          return null;
        }

        const tab = {
          id: 'tab_' + this._nextId++,
          title: title || (cascadeId ? ('Chat ' + cascadeId.substring(0, 8)) : 'New Chat'),
          cascadeId: cascadeId || null,
          timestamp: Date.now(),
          stale: false,
          customTitle: false,
          busy: false,
          activityUnseen: false
        };
        this._tabs.push(tab);
        this._activeTabId = tab.id;
        return tab;
      }

      _onAddTab() {
        if (!this._bridgeReady) {
          this._log('warn', 'Bridge not ready, cannot add tab');
          return;
        }

        // è¾¾åˆ°ä¸Šé™æ—¶æ˜¾ç¤º toast æç¤ºï¼Œä¸æ–°å¢ Tab
        if (this._tabs.length >= this._maxTabs) {
          this._showToast('å·²è¾¾ä¸Šé™ï¼Œè¯·å…ˆå…³é—­æ ‡ç­¾');
          this._log('info', 'Tab limit reached:', this._maxTabs);
          return;
        }

        // Capture current conversation's cascadeId on active tab before creating new
        const activeTab = this._tabs.find(t => t.id === this._activeTabId);
        if (activeTab && !activeTab.cascadeId) {
          const currentId = window._agBridge.getCurrentCascadeId();
          if (currentId) {
            activeTab.cascadeId = currentId;
            const title = this._getTitleForCascadeId(currentId);
            if (title) activeTab.title = title;
          }
        }

        // Start new conversation via bridge
        const success = window._agBridge.startNewConversation();
        if (!success) {
          this._log('error', 'Failed to start new conversation');
          return;
        }

        // åˆ›å»ºæ–° Tabï¼ˆcascadeId ä¼šåœ¨ sync ä¸­ç»‘å®šï¼‰
        this._addTabInternal('New Chat', null);
        this._renderTabs();
        this._saveTabs();
        this._log('info', 'Added new tab');
      }

      _onCloseTab(tabId) {
        const idx = this._tabs.findIndex(t => t.id === tabId);
        if (idx === -1) return;

        // Don't close the last tab
        if (this._tabs.length <= 1) return;

        const wasActive = this._activeTabId === tabId;
        this._tabs.splice(idx, 1);

        if (wasActive) {
          // Switch to adjacent tab
          const newIdx = Math.min(idx, this._tabs.length - 1);
          const newTab = this._tabs[newIdx];
          this._activeTabId = newTab.id;
          if (newTab.cascadeId && this._bridgeReady) {
            this._doSwitch(newTab);
          }
        }

        this._renderTabs();
        this._saveTabs();
        this._log('info', 'Closed tab', tabId);
      }

      _onClickTab(tabId) {
        if (tabId === this._activeTabId) {
          // Clicking active tab = "å·²è¯»", clear unseen
          const tab = this._tabs.find(t => t.id === tabId);
          if (tab && tab.activityUnseen) {
            tab.activityUnseen = false;
            this._renderTabs();
          }
          return;
        }
        const tab = this._tabs.find(t => t.id === tabId);
        if (!tab) return;

        // Clicking any tab = user is reading it â†’ mark as seen
        tab.activityUnseen = false;

        if (!this._bridgeReady) {
          this._log('warn', 'Bridge not ready');
          this._shakeTab(tabId);
          return;
        }

        // Capture current cascadeId on previously active tab
        const prevTab = this._tabs.find(t => t.id === this._activeTabId);
        if (prevTab && !prevTab.cascadeId) {
          const currentId = window._agBridge.getCurrentCascadeId();
          if (currentId) {
            prevTab.cascadeId = currentId;
            const title = this._getTitleForCascadeId(currentId);
            if (title) prevTab.title = title;
          }
        }

        if (!tab.cascadeId) {
          // No cascadeId - start new conversation
          this._activeTabId = tabId;
          window._agBridge.startNewConversation();
          this._renderTabs();
          this._saveTabs();
          return;
        }

        this._doSwitch(tab);
      }

      // --- Switch with debounce and state machine ---
      _doSwitch(tab) {
        const switchId = ++this._switchId;
        this._state = 'switching';
        this._activeTabId = tab.id;
        this._renderTabs();
        this._log('debug', 'Switching to', tab.cascadeId, 'switchId:', switchId);

        // Debounce: if another switch happens, this one is cancelled
        setTimeout(() => {
          if (this._destroyed) return;
          if (this._switchId !== switchId) {
            this._state = 'cancelled';
            this._log('debug', 'Switch cancelled, switchId:', switchId);
            return;
          }

          // Attempt switch via bridge
          const success = window._agBridge.switchConversation(tab.cascadeId);

          if (this._switchId !== switchId) {
            this._state = 'cancelled';
            return;
          }

          if (success) {
            this._state = 'verifying';

            // Verify switch after short delay
            setTimeout(() => {
              if (this._destroyed) return;
              if (this._switchId !== switchId) {
                this._state = 'cancelled';
                return;
              }

              const currentId = window._agBridge.getCurrentCascadeId();
              if (currentId === tab.cascadeId) {
                this._state = 'success';
                tab.stale = false;
                this._log('info', 'Switch verified:', tab.cascadeId);
              } else {
                this._state = 'failed';
                this._log('warn', 'Switch verification failed, expected:', tab.cascadeId, 'got:', currentId);
                tab.stale = true;
                this._shakeTab(tab.id);
              }
              this._renderTabs();
              this._saveTabs();
              this._state = 'idle';
            }, 800);
          } else {
            this._state = 'failed';
            tab.stale = true;
            this._shakeTab(tab.id);
            this._renderTabs();
            this._saveTabs();
            this._log('error', 'Switch failed for:', tab.cascadeId);
            this._state = 'idle';
          }
        }, 50); // small debounce window
      }

      _shakeTab(tabId) {
        const el = this._scrollArea?.querySelector(`[data-tab-id="${tabId}"]`);
        if (el) {
          el.classList.add('shake');
          setTimeout(() => el.classList.remove('shake'), 500);
        }
      }

      // --- Rename ---
      _startRename(tab, spanEl) {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'ag-tab-rename-input';
        input.value = tab.title;
        input.style.width = Math.max(spanEl.offsetWidth, 40) + 'px';

        let committed = false;
        const commit = () => {
          if (committed) return;
          committed = true;
          const val = input.value.trim();
          if (val && val !== tab.title) {
            tab.title = val;
            tab.customTitle = true;
            this._saveTabs();
          }
          this._renderTabs();
        };
        const cancel = () => {
          if (committed) return;
          committed = true;
          this._renderTabs();
        };

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commit(); }
          if (e.key === 'Escape') { e.preventDefault(); cancel(); }
        });
        input.addEventListener('blur', () => commit());

        spanEl.replaceWith(input);
        input.focus();
        input.select();
      }

      // --- Rendering ---
      _renderTabs() {
        if (!this._scrollArea) return;
        this._scrollArea.innerHTML = '';

        this._tabs.forEach(tab => {
          const el = document.createElement('div');
          el.className = 'ag-tab-item' + (tab.id === this._activeTabId ? ' active' : '');
          el.dataset.tabId = tab.id;
          if (tab.stale) el.dataset.stale = 'true';
          const isActive = tab.busy || tab.activityUnseen;
          if (isActive) el.dataset.busy = 'true';

          // Status dot (always visible: green=busy/unseen, gray=idle)
          const dot = document.createElement('span');
          dot.className = 'ag-tab-dot' + (isActive ? ' active-dot' : '');
          el.appendChild(dot);

          const titleSpan = document.createElement('span');
          titleSpan.textContent = tab.stale ? tab.title + ' [!]' : tab.title;
          titleSpan.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            this._startRename(tab, titleSpan);
          });
          el.appendChild(titleSpan);

          // Close button (only if more than 1 tab)
          if (this._tabs.length > 1) {
            const closeSpan = document.createElement('span');
            closeSpan.className = 'ag-tab-close';
            closeSpan.textContent = '\u00d7';
            closeSpan.addEventListener('click', (e) => {
              e.stopPropagation();
              this._onCloseTab(tab.id);
            });
            el.appendChild(closeSpan);
          }

          el.addEventListener('click', () => this._onClickTab(tab.id));
          this._scrollArea.appendChild(el);
        });

        // Scroll active tab into view
        const activeEl = this._scrollArea.querySelector('.active');
        if (activeEl) {
          activeEl.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
        }
        this._updateScrollArrows();
        this._updateCounter();
      }

      // --- Title Updates ---
      updateTabTitles() {
        if (!this._bridgeReady) return;
        try {
          let changed = false;
          this._tabs.forEach(tab => {
            if (!tab.cascadeId) return;
            if (tab.customTitle) return;
            // Use multi-source title lookup
            const title = window._agBridge.findConversationTitle(tab.cascadeId);
            if (title) {
              const newTitle = title.substring(0, 40);
              if (newTitle !== tab.title) {
                tab.title = newTitle;
                changed = true;
              }
              if (tab.stale) {
                tab.stale = false;
                changed = true;
              }
            }
          });
          if (changed) {
            this._renderTabs();
            this._saveTabs();
          }
          // é€’è¿›å¼é‡è¯•ï¼šæ ‡é¢˜å¯èƒ½éœ€è¦ AI å›å¤åæ‰ç”Ÿæˆï¼ŒæŒç»­é‡è¯•æœ€å¤š 5 æ¬¡
          const hasDefault = this._tabs.some(t => t.cascadeId && !t.customTitle && (t.title === 'New Tab' || t.title === 'Current Chat' || t.title === 'New Chat' || t.title.startsWith('Chat ')));
          if (hasDefault) {
            const retryCount = this._titleRetryCount || 0;
            if (retryCount < 5 && !this._titleRetryTimer) {
              this._titleRetryCount = retryCount + 1;
              // é€’è¿›å»¶è¿Ÿ: 2s, 3s, 4.5s, 6.75s, 10s
              const delay = Math.min(2000 * Math.pow(1.5, retryCount), 10000);
              this._titleRetryTimer = setTimeout(() => {
                this._titleRetryTimer = null;
                this.updateTabTitles();
              }, delay);
            }
          } else {
            // æ‰€æœ‰æ ‡é¢˜å·²è·å–ï¼Œé‡ç½®é‡è¯•è®¡æ•°
            this._titleRetryCount = 0;
          }
        } catch (e) {
          this._log('warn', 'Title update failed:', e.message);
        }
      }

      // --- Settings Update ---
      setMaxTabs(maxTabs) {
        this._maxTabs = maxTabs;
        // è¶…é™æ—¶ç§»é™¤æœ€æ—©çš„éæ´»è·ƒ Tab
        while (this._tabs.length > this._maxTabs) {
          const removeIdx = this._tabs.findIndex(t => t.id !== this._activeTabId);
          if (removeIdx !== -1) {
            this._tabs.splice(removeIdx, 1);
          } else {
            this._tabs.shift();
          }
        }
        this._renderTabs();
        this._saveTabs();
      }

      // --- Destroy ---
      destroy() {
        this._destroyed = true;
        if (this._pollTimer) clearTimeout(this._pollTimer);
        if (this._syncTimer) clearInterval(this._syncTimer);
        if (this._busyTimer) clearInterval(this._busyTimer);
        if (this._titleRetryTimer) clearTimeout(this._titleRetryTimer);
        if (this._toastTimer) clearTimeout(this._toastTimer);
        if (this._resizeHandler) window.removeEventListener('resize', this._resizeHandler);
        // ç§»é™¤é”®ç›˜äº‹ä»¶ç›‘å¬
        if (this._keydownHandler && this._container) {
          this._container.removeEventListener('keydown', this._keydownHandler);
        }
        if (this._container && this._container.parentNode) {
          this._container.parentNode.removeChild(this._container);
        }
        // ç§»é™¤ toast å…ƒç´ 
        if (this._toastEl && this._toastEl.parentNode) {
          this._toastEl.parentNode.removeChild(this._toastEl);
        }
        this._container = null;
        this._scrollArea = null;
        this._scrollLeftBtn = null;
        this._scrollRightBtn = null;
        this._counterEl = null;
        this._toastEl = null;
        document.body.classList.remove('ag-tab-bar-active');
        this._log('info', 'Tab bar destroyed');
      }
    }

    // Global reference (exposed on window for debugging)
    let _tabManager = null;
    Object.defineProperty(window, '_tabManager', { get: () => _tabManager, configurable: true });

    function initTabBar() {
      if (_tabManager) {
        _tabManager.destroy();
        _tabManager = null;
      }
      if (!currentSettings.tabBarEnabled) return;
      _tabManager = new HistoryTabManager(currentSettings.tabBarMaxTabs);
      _tabManager.init();
      // æ ‡é¢˜æ›´æ–°å·²æ•´åˆåˆ° 3s sync è½®è¯¢ä¸­ï¼Œæ— éœ€ç‹¬ç«‹å®šæ—¶å™¨
    }

    function destroyTabBar() {
      if (_tabManager) {
        _tabManager.destroy();
        _tabManager = null;
      }
    }

    /* ===== åˆå§‹åŒ– ===== */
    function initUI() {
      // 0. æ˜¾ç¤ºå½“å‰ç‰ˆæœ¬å·
      const versionEl = document.getElementById('current-version');
      if (versionEl) versionEl.textContent = 'v' + APP_VERSION;

      // 1. è®¾ç½®æ§ä»¶çŠ¶æ€
      masterToggle.checked = currentSettings.masterEnabled;
      copyMasterToggle.checked = currentSettings.copyEnabled;
      hotkeyMasterToggle.checked = currentSettings.hotkeyEnabled;
      sendHotkeySelect.value = currentSettings.sendHotkey;

      COLOR_CONFIGS.forEach(c => {
        const t = document.getElementById(`toggle-${c.id}`);
        const col = document.getElementById(`color-${c.id}`);
        if (t) t.checked = currentSettings.colors[c.id].enabled;
        if (col) col.value = currentSettings.colors[c.id].color;
      });

      COPY_CONFIGS.forEach(c => {
        const t = document.getElementById(`toggle-${c.id}`);
        if (t) t.checked = currentSettings.copy[c.id]?.enabled ?? true;
      });

      // å­—ä½“å¤§å°æ§ä»¶åˆå§‹åŒ–
      fontsizeMasterToggle.checked = currentSettings.fontsizeMasterEnabled;
      FONTSIZE_CONFIGS.forEach(c => {
        const t = document.getElementById(`toggle-fontsize-${c.id}`);
        const sizeEl = document.getElementById(`fontsize-${c.id}`);
        if (t) t.checked = currentSettings.fontsizes[c.id].enabled;
        if (sizeEl) sizeEl.value = currentSettings.fontsizes[c.id].size;
      });

      // 2. è‡ªåŠ¨æ“ä½œåˆå§‹åŒ–
      if (autoAcceptMasterToggle) {
        autoAcceptMasterToggle.checked = currentSettings.autoAcceptEnabled;
      }
      renderPatternCheckboxes();
      if (bannedCommandsInput) {
        bannedCommandsInput.value = currentSettings.bannedCommands.join('\n');
      }
      updateStatsUI();

      // 3. åº”ç”¨åŠŸèƒ½
      applyColorSettings();
      applyFontsizeSettings();
      applyCopySettings();
      applyHotkeySettings();
      applyAutoAcceptSettings();
      updateLanguage();

      // LaTeX åˆå§‹åŒ–
      if (latexMasterToggle) {
        latexMasterToggle.checked = currentSettings.latexEnabled;
      }
      if (currentSettings.latexEnabled) {
        applyLatexSettings();
      }

      // 4. ç³»ç»Ÿè®¾ç½®åˆå§‹åŒ–
      const autoUpdateToggle = document.getElementById('auto-update-toggle');
      const manualUpdateBtn = document.getElementById('manual-update-btn');

      if (autoUpdateToggle) {
        autoUpdateToggle.checked = currentSettings.autoUpdateEnabled;
        autoUpdateToggle.addEventListener('change', () => {
          currentSettings.autoUpdateEnabled = autoUpdateToggle.checked;
          saveSettings(currentSettings);
        });
      }

      if (manualUpdateBtn) {
        manualUpdateBtn.addEventListener('click', manualCheckUpdate);
      }

      // 5. Tab Bar åˆå§‹åŒ–
      const tabBarToggle = document.getElementById('tab-bar-master-toggle');
      const tabBarMaxTabsSelect = document.getElementById('tab-bar-max-tabs');

      if (tabBarToggle) {
        tabBarToggle.checked = currentSettings.tabBarEnabled;
        tabBarToggle.addEventListener('change', () => {
          currentSettings.tabBarEnabled = tabBarToggle.checked;
          saveSettings(currentSettings);
          if (currentSettings.tabBarEnabled) {
            initTabBar();
          } else {
            destroyTabBar();
          }
        });
      }

      if (tabBarMaxTabsSelect) {
        tabBarMaxTabsSelect.value = String(currentSettings.tabBarMaxTabs);
        tabBarMaxTabsSelect.addEventListener('change', () => {
          currentSettings.tabBarMaxTabs = parseInt(tabBarMaxTabsSelect.value, 10) || 10;
          saveSettings(currentSettings);
          if (_tabManager) _tabManager.setMaxTabs(currentSettings.tabBarMaxTabs);
        });
      }

      // Initialize tab bar if enabled
      if (currentSettings.tabBarEnabled) {
        initTabBar();
      }

      // 6. å¯åŠ¨æ—¶ç‰ˆæœ¬æ£€æµ‹ï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if (currentSettings.autoUpdateEnabled) {
        setTimeout(checkForUpdate, 10000);
      }
    }

    if (document.readyState !== 'loading') initUI();
    else document.addEventListener('DOMContentLoaded', initUI);
  </script>
</body>

</html>