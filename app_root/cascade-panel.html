<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <style>
    /* ===== è‡ªå®šä¹‰é¢œè‰²å˜é‡ ===== */
    :root {
      --color-user-message: #60A5FA;
      --color-ai-response: #E0E0E0;
      --color-code-block: #A78BFA;
      --color-action-status: #4ADE80;
      --color-thinking: #9CA3AF;
      /* å­—ä½“å¤§å°å˜é‡ */
      --fontsize-user-message: 14px;
      --fontsize-ai-response: 14px;
      --fontsize-code-block: 13px;
      --fontsize-action-status: 13px;
      --fontsize-thinking: 13px;
      --bg-modal: #1e1e1e;
      --border-color: #3c3c3c;
      --accent-color: #667eea;
      --text-main: #fff;
      --text-sub: #999;
    }

    /* ===== Animation Keyframes ===== */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ===== æ‚¬æµ®æŒ‰é’®æ ·å¼ ===== */
    #settings-toggle-btn {
      position: fixed;
      right: 0;
      top: 66%;
      transform: translateY(-50%);
      width: 28px;
      height: 48px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: -2px 2px 8px rgba(0, 0, 0, 0.3);
      z-index: 9999;
      transition: all 0.3s ease;
    }

    #settings-toggle-btn:hover {
      width: 36px;
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }

    #settings-toggle-btn svg {
      width: 18px;
      height: 18px;
      fill: white;
      transition: transform 0.3s ease;
    }

    #settings-toggle-btn:hover svg {
      transform: rotate(90deg);
    }

    /* ===== å¼¹çª—é®ç½©å±‚ ===== */
    #settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      align-items: center;
      justify-content: center;
    }

    #settings-overlay.show {
      display: flex;
    }

    #settings-overlay.visible {
      opacity: 1;
    }

    /* ===== è®¾ç½®å¼¹çª— ===== */
    #settings-modal {
      background: var(--bg-modal);
      border-radius: 12px;
      width: 400px;
      max-width: 90%;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid var(--border-color);
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      overflow: hidden;
    }

    #settings-overlay.visible #settings-modal {
      transform: scale(1);
    }

    /* å¼¹çª— Header */
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, 0.02);
    }

    .header-left {
      display: flex;
      flex-direction: column;
    }

    .brand-name {
      color: var(--text-main);
      font-size: 16px;
      font-weight: 700;
      background: linear-gradient(90deg, #fff, #a5b4fc);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .brand-links {
      display: flex;
      gap: 12px;
      margin-top: 4px;
    }

    .brand-link {
      color: var(--text-sub);
      font-size: 10px;
      text-decoration: none;
      transition: color 0.2s;
    }

    .brand-link:hover {
      color: var(--accent-color);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .lang-switch {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-sub);
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .lang-switch:hover {
      border-color: var(--text-main);
      color: var(--text-main);
    }

    .modal-close {
      background: none;
      border: none;
      color: var(--text-sub);
      font-size: 20px;
      cursor: pointer;
      padding: 0;
      line-height: 1;
      transition: color 0.2s;
    }

    .modal-close:hover {
      color: var(--text-main);
    }

    /* é€‰é¡¹å¡å¯¼èˆª */
    .tab-nav {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      padding: 0 10px;
      background: rgba(0, 0, 0, 0.1);
    }

    .tab-btn {
      flex: 1;
      background: none;
      border: none;
      color: var(--text-sub);
      padding: 12px;
      font-size: 13px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      color: var(--text-main);
    }

    .tab-btn.active {
      color: var(--accent-color);
      font-weight: 600;
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--accent-color);
    }

    /* å†…å®¹åŒºåŸŸ */
    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 0;
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.2s ease;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* æ‰‹é£ç´æ•ˆæœ */
    .accordion-item {
      border-bottom: 1px solid var(--border-color);
    }

    .accordion-header {
      padding: 14px 20px;
      background: rgba(255, 255, 255, 0.01);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: background 0.2s;
    }

    .accordion-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .accordion-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-main);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .accordion-icon {
      font-size: 10px;
      color: var(--text-sub);
      transition: transform 0.3s;
    }

    .accordion-item.expanded .accordion-icon {
      transform: rotate(180deg);
    }

    .accordion-body {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s cubic-bezier(0, 1, 0, 1);
      background: rgba(0, 0, 0, 0.1);
    }

    .accordion-item.expanded .accordion-body {
      max-height: 1000px;
      /* è¶³å¤Ÿå¤§çš„å€¼ */
      transition: max-height 0.3s ease-in-out;
    }

    .accordion-inner {
      padding: 16px 20px;
    }

    /* é€šç”¨æ§ä»¶æ ·å¼ */
    .main-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: rgba(102, 126, 234, 0.1);
      border: 1px solid rgba(102, 126, 234, 0.2);
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .main-toggle-label {
      color: var(--text-main);
      font-size: 13px;
      font-weight: 500;
    }

    .setting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .setting-item:last-child {
      border-bottom: none;
    }

    .setting-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .setting-icon {
      font-size: 15px;
      width: 20px;
      text-align: center;
      color: var(--text-sub);
    }

    .setting-name {
      color: #ccc;
      font-size: 13px;
    }

    .setting-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 32px;
      height: 18px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #3c3c3c;
      transition: 0.3s;
      border-radius: 20px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 12px;
      width: 12px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-switch input:checked+.toggle-slider {
      background: var(--accent-color);
    }

    .toggle-switch input:checked+.toggle-slider:before {
      transform: translateX(14px);
    }

    /* Color Input */
    .color-input {
      width: 24px;
      height: 24px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
      background: none;
    }

    .color-input::-webkit-color-swatch-wrapper {
      padding: 2px;
    }

    .color-input::-webkit-color-swatch {
      border-radius: 2px;
      border: none;
    }

    /* Select Input */
    .select-input {
      background: #2d2d2d;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 8px;
      color: #ccc;
      font-size: 12px;
      cursor: pointer;
      outline: none;
      min-width: 110px;
    }

    .select-input:focus {
      border-color: var(--accent-color);
    }

    /* ===== é¢œè‰²è¦†ç›–æ ·å¼ ===== */
    /* ç”¨æˆ·æ¶ˆæ¯ */
    #react-app.color-user-message .bg-gray-500\/15 .whitespace-pre-wrap,
    #react-app.color-user-message .bg-gray-500\/15 [style*="word-break"] {
      color: var(--color-user-message) !important;
    }

    /* AIå›å¤ (æ’é™¤æ€è€ƒ) */
    #react-app.color-ai-response .prose:not(.opacity-70) p,
    #react-app.color-ai-response .prose:not(.opacity-70) li,
    #react-app.color-ai-response .prose:not(.opacity-70) h2,
    #react-app.color-ai-response .prose:not(.opacity-70) h3,
    #react-app.color-ai-response .prose:not(.opacity-70) strong,
    #react-app.color-ai-response .prose:not(.opacity-70) ul,
    #react-app.color-ai-response .prose:not(.opacity-70) ol,
    #react-app.color-ai-response .prose:not(.opacity-70) table,
    #react-app.color-ai-response .prose:not(.opacity-70) th,
    #react-app.color-ai-response .prose:not(.opacity-70) td {
      color: var(--color-ai-response) !important;
    }

    /* ä»£ç å— */
    #react-app.color-code-block pre,
    #react-app.color-code-block pre code,
    #react-app.color-code-block .code-block,
    #react-app.color-code-block .code-line {
      color: var(--color-code-block) !important;
    }

    /* æ“ä½œçŠ¶æ€ */
    #react-app.color-action-status .shrink-0:is(:contains('Analyzed'), :contains('Created'), :contains('Edited')),
    #react-app.color-action-status [class*="animate-fade-in"] .truncate {
      color: var(--color-action-status) !important;
    }

    /* æ€è€ƒè¿‡ç¨‹ */
    #react-app.color-thinking .opacity-70.prose,
    #react-app.color-thinking .opacity-70.prose * {
      color: var(--color-thinking) !important;
    }

    /* ===== å­—ä½“å¤§å°è¦†ç›–æ ·å¼ ===== */
    /* ç”¨æˆ·æ¶ˆæ¯å­—ä½“å¤§å° */
    #react-app.fontsize-user-message .bg-gray-500\/15 .whitespace-pre-wrap,
    #react-app.fontsize-user-message .bg-gray-500\/15 [style*="word-break"] {
      font-size: var(--fontsize-user-message) !important;
    }

    /* AIå›å¤å­—ä½“å¤§å° */
    #react-app.fontsize-ai-response .prose:not(.opacity-70) p,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) li,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) h2,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) h3,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) strong,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) ul,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) ol,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) table,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) th,
    #react-app.fontsize-ai-response .prose:not(.opacity-70) td {
      font-size: var(--fontsize-ai-response) !important;
    }

    /* ä»£ç å—å­—ä½“å¤§å° */
    #react-app.fontsize-code-block pre,
    #react-app.fontsize-code-block pre code,
    #react-app.fontsize-code-block .code-block,
    #react-app.fontsize-code-block .code-line {
      font-size: var(--fontsize-code-block) !important;
    }

    /* æ“ä½œçŠ¶æ€å­—ä½“å¤§å° */
    #react-app.fontsize-action-status .shrink-0:is(:contains('Analyzed'), :contains('Created'), :contains('Edited')),
    #react-app.fontsize-action-status [class*="animate-fade-in"] .truncate {
      font-size: var(--fontsize-action-status) !important;
    }

    /* æ€è€ƒè¿‡ç¨‹å­—ä½“å¤§å° */
    #react-app.fontsize-thinking .opacity-70.prose,
    #react-app.fontsize-thinking .opacity-70.prose * {
      font-size: var(--fontsize-thinking) !important;
    }

    /* ===== å¤åˆ¶æŒ‰é’®æ ·å¼ ===== */
    .copy-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 26px;
      height: 26px;
      background: rgba(60, 60, 60, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.2s ease;
      z-index: 10;
    }

    .copy-btn svg {
      width: 14px;
      height: 14px;
      fill: #ccc;
    }

    .copy-btn:hover {
      background: rgba(102, 126, 234, 0.8);
      border-color: rgba(102, 126, 234, 0.5);
    }

    .copy-btn:hover svg {
      fill: #fff;
    }

    .copy-btn.copied {
      background: rgba(74, 222, 128, 0.8);
    }

    .copy-btn.copied svg {
      fill: #fff;
    }

    .copy-target {
      position: relative;
    }

    .copy-target:hover .copy-btn {
      opacity: 1;
    }

    /* ===== Toast æç¤ºæ ·å¼ ===== */
    #retry-toast {
      position: fixed;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 13px;
      z-index: 20000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease, top 0.3s ease;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #retry-toast.show {
      display: flex;
      opacity: 1;
      top: 60px;
    }

    #retry-toast.success {
      background: rgba(46, 125, 50, 0.9);
      border-color: rgba(76, 175, 80, 0.3);
    }

    .toast-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top: 2px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* ===== è‡ªåŠ¨æ“ä½œåŠŸèƒ½æ ·å¼ ===== */
    /* æŒ‰é’®ç±»å‹ Grid */
    .pattern-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 12px 0;
    }

    .pattern-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
      color: #ccc;
    }

    .pattern-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .pattern-item.active {
      border-color: var(--accent-color);
      background: rgba(102, 126, 234, 0.15);
      color: var(--text-main);
    }

    .pattern-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    /* ç»Ÿè®¡é¢æ¿ */
    .stats-panel {
      display: flex;
      justify-content: space-around;
      padding: 12px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      margin-top: 12px;
    }

    .stat-item {
      text-align: center;
      flex: 1;
    }

    .stat-icon {
      font-size: 16px;
      display: block;
      margin-bottom: 4px;
    }

    .stat-value {
      display: block;
      font-size: 18px;
      font-weight: 700;
      color: var(--text-main);
    }

    .stat-label {
      font-size: 10px;
      color: var(--text-sub);
      text-transform: uppercase;
    }

    /* å±é™©å‘½ä»¤è¾“å…¥æ¡† */
    .banned-textarea {
      width: 100%;
      min-height: 100px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: #ccc;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 11px;
      padding: 10px;
      resize: vertical;
      outline: none;
      box-sizing: border-box;
    }

    .banned-textarea:focus {
      border-color: var(--accent-color);
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .btn-action {
      flex: 1;
      padding: 8px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn-action.primary {
      background: var(--accent-color);
      color: white;
    }

    .btn-action.primary:hover {
      filter: brightness(1.1);
    }

    .btn-action.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #ccc;
      border: 1px solid var(--border-color);
    }

    .btn-action.secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .save-status {
      font-size: 11px;
      text-align: center;
      margin-top: 8px;
      min-height: 16px;
      color: #4ADE80;
    }

    /* ===== LaTeX å…¬å¼æ¸²æŸ“æ ·å¼ ===== */
    /* å—çº§å…¬å¼å±…ä¸­ */
    .latex-block {
      display: block;
      text-align: center;
      margin: 1em 0;
      overflow-x: auto;
    }

    /* é”™è¯¯æç¤ºæ ·å¼ */
    .latex-error {
      color: #f87171;
      font-size: 12px;
      background: rgba(248, 113, 113, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }

    .setting-desc {
      font-size: 11px;
      color: var(--text-sub);
      margin-bottom: 12px;
      line-height: 1.5;
    }

    /* å­—ä½“å¤§å°è¾“å…¥æ¡† */
    .fontsize-input {
      width: 50px;
      background: #2d2d2d;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 4px 6px;
      color: #ccc;
      font-size: 12px;
      text-align: center;
      outline: none;
    }

    .fontsize-input:focus {
      border-color: var(--accent-color);
    }

    /* åŒæ­¥æŒ‰é’® */
    .sync-btn {
      background: rgba(102, 126, 234, 0.2);
      border: 1px solid var(--accent-color);
      border-radius: 4px;
      color: var(--accent-color);
      font-size: 11px;
      padding: 3px 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 6px;
    }

    .sync-btn:hover {
      background: var(--accent-color);
      color: #fff;
    }

    /* ç‰ˆæœ¬å·æ ‡ç­¾ */
    .version-tag {
      font-size: 10px;
      color: var(--text-sub);
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
      font-weight: normal;
    }

    /* æ›´æ–°æç¤ºæ¡ */
    .update-banner {
      display: none;
      background: linear-gradient(90deg, rgba(74, 222, 128, 0.15), rgba(102, 126, 234, 0.15));
      border: 1px solid rgba(74, 222, 128, 0.3);
      border-radius: 6px;
      padding: 8px 12px;
      margin-top: 10px;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      animation: fadeIn 0.3s ease;
    }

    .update-banner.show {
      display: flex;
    }

    .update-text {
      font-size: 12px;
      color: #4ADE80;
    }

    .update-text span {
      font-weight: 600;
    }

    .update-version {
      background: rgba(74, 222, 128, 0.3);
      padding: 1px 6px;
      border-radius: 4px;
      margin-left: 4px;
    }

    .update-close {
      background: none;
      border: none;
      color: rgba(74, 222, 128, 0.6);
      font-size: 16px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
      transition: color 0.2s;
    }

    .update-close:hover {
      color: #4ADE80;
    }

    .update-btn {
      background: #4ADE80;
      color: #1e1e1e;
      border: none;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
    }

    .update-btn:hover {
      background: #22c55e;
    }

    /* Translator Styles */
    .translator-input {
      width: 100%;
      padding: 8px;
      background: #2d2d2d;
      border: 1px solid var(--border-color);
      color: #ccc;
      border-radius: 4px;
      margin-bottom: 8px;
      margin-top: 8px;
    }

    .bridge-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin-left: 5px;
      background: #555;
    }

    .bridge-status.connected {
      background: #4ADE80;
      box-shadow: 0 0 5px #4ADE80;
    }

    .bridge-status.error {
      background: #EF4444;
    }

    .translate-btn {
      position: absolute !important;
      bottom: 2px !important;
      right: 85px !important;
      /* Shifted left to avoid overlap */
      background: transparent;
      box-sizing: border-box;
      /* Fix layout */
      border: 1px solid transparent;
      /* Reserve space for border */
      color: var(--accent-color);
      cursor: pointer;
      opacity: 0.8;
      /* transition: all 0.2s;  REMOVED for static feel */
      padding: 3px 5px;
      /* Reduced by 1px to compensate for border */
      display: inline-flex;
      align-items: center;
      gap: 6px;
      /* Space between icon and text */
      z-index: 9999 !important;
      /* Higher z-index to stay on top */
      font-size: 11px;
      /* Match typical toolbar status text */
      font-family: var(--font-family);
      border-radius: 4px;
      /* Prevent layout thrashing and composite separately */
      will-change: transform;
      transform: translateZ(0);
      pointer-events: auto !important;
      /* Ensure clickability */
    }

    .translate-btn:hover {
      /* REMOVED background and filter for no-animation style */
      background: transparent;
      color: var(--accent-color);
      opacity: 1;
    }

    /* Input Translator */
    .input-wrapper-relative {
      position: relative !important;
    }

    .input-translate-btn {
      box-sizing: border-box;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid transparent;
      /* Always present transparent border */
      color: var(--text-secondary);
      border-radius: 6px;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      z-index: 1000;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: background 0.1s, color 0.1s;
      /* Faster transition */
      white-space: nowrap;
      height: 24px;
      /* Fixed height */
      margin-left: 4px;
      margin-right: 4px;
      opacity: 0.7;
      /* Prevent layout thrashing */
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    .input-translate-btn:hover {
      opacity: 1;
      background: var(--accent-color);
      color: #fff;
      border: 1px solid transparent;
      /* Keep border transparent */
    }

    .input-translate-btn.input-translate-btn-absolute {
      position: absolute;
      bottom: 6px;
      right: 6px;
      margin: 0;
    }

    .input-translate-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .translate-btn:hover {
      opacity: 1;
      bottom: -21px;
    }

    .translation-result {
      margin-top: 8px;
      padding: 10px;
      background: rgba(102, 126, 234, 0.08);
      border-left: 3px solid var(--accent-color);
      font-size: 0.95em;
      color: var(--text-main);
      white-space: pre-wrap;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  </style>
</head>

<body style="margin: 0">
  <div id="react-app" class="react-app-container"></div>

  <div id="retry-toast">
    <div class="toast-spinner"></div>
    <span id="retry-toast-text"></span>
  </div>

  <!-- æ‚¬æµ®è®¾ç½®æŒ‰é’® -->
  <button id="settings-toggle-btn" title="Open Settings">
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M19.14,12.94c0.04-0.31,0.06-0.63,0.06-0.94c0-0.31-0.02-0.63-0.06-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.37,4.8,11.69,4.8,12s0.02,0.63,0.06,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z" />
    </svg>
  </button>

  <!-- è®¾ç½®å¼¹çª— -->
  <div id="settings-overlay">
    <div id="settings-modal">
      <!-- Header -->
      <div class="modal-header">
        <div class="header-left">
          <span class="brand-name">Antigravity Better<span class="version-tag" id="current-version"></span></span>
          <div class="brand-links">
            <a href="https://dpit.lib00.com" target="_blank" class="brand-link">ğŸŒ dpit.lib00.com</a>
            <a href="https://github.com/016/Antigravity-Better" target="_blank" class="brand-link">ğŸ“¦ GitHub</a>
          </div>
          <!-- æ›´æ–°æç¤ºæ¡ -->
          <div class="update-banner" id="update-banner">
            <span class="update-text">ğŸ‰ <span data-i18n="update_available">æ–°ç‰ˆæœ¬å¯ç”¨</span> <span id="new-version"
                class="update-version"></span></span>
            <span>
              <a href="https://github.com/016/Antigravity-Better/releases" target="_blank" class="update-btn"
                data-i18n="btn_download">ä¸‹è½½æ›´æ–°</a>
              <button class="update-close" id="update-close-btn" title="Close">&times;</button>
            </span>
          </div>
        </div>
        <div class="header-right">
          <button class="lang-switch" id="lang-switch">ğŸŒ En/ä¸­</button>
          <button class="modal-close" id="modal-close-btn">&times;</button>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="appearance" data-i18n="tab_appearance">ğŸ¨ å¤–è§‚</button>
        <button class="tab-btn" data-tab="features" data-i18n="tab_features">ğŸ› ï¸ åŠŸèƒ½</button>
        <button class="tab-btn" data-tab="system" data-i18n="tab_system">âš™ï¸ ç³»ç»Ÿ</button>
      </div>

      <!-- Content -->
      <div class="modal-body">
        <!-- Tab: Appearance -->
        <div class="tab-content active" id="tab-appearance">
          <!-- Accordion: Colors -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="colors_title">ğŸ¨ é¢œè‰²è‡ªå®šä¹‰</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_custom_colors">å¯ç”¨è‡ªå®šä¹‰é¢œè‰²</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="color-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ“</span>
                      <span class="setting-name" data-i18n="lbl_user_msg">ç”¨æˆ·æ¶ˆæ¯</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-user-message" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-user-message" class="color-input" value="#60A5FA">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ¤–</span>
                      <span class="setting-name" data-i18n="lbl_ai_resp">AIå›å¤</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-ai-response" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-ai-response" class="color-input" value="#E0E0E0">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’»</span>
                      <span class="setting-name" data-i18n="lbl_code">ä»£ç å—</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-code-block" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-code-block" class="color-input" value="#A78BFA">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">âœ…</span>
                      <span class="setting-name" data-i18n="lbl_status">æ“ä½œçŠ¶æ€</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-action-status">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-action-status" class="color-input" value="#4ADE80">
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’­</span>
                      <span class="setting-name" data-i18n="lbl_thinking">æ€è€ƒè¿‡ç¨‹</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-thinking">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="color" id="color-thinking" class="color-input" value="#9CA3AF">
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: Font Size -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="fontsize_title">ğŸ”¤ å­—ä½“å¤§å°</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_custom_fontsize">å¯ç”¨è‡ªå®šä¹‰å­—ä½“å¤§å°</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="fontsize-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="fontsize-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ“</span>
                      <span class="setting-name" data-i18n="lbl_user_msg">ç”¨æˆ·æ¶ˆæ¯</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-user-message" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-user-message" class="fontsize-input" value="14" min="10"
                        max="24"> px
                      <button id="fontsize-sync-btn" class="sync-btn" data-i18n="btn_sync">åŒæ­¥å…¨éƒ¨</button>
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ¤–</span>
                      <span class="setting-name" data-i18n="lbl_ai_resp">AIå›å¤</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-ai-response" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-ai-response" class="fontsize-input" value="14" min="10"
                        max="24"> px
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’»</span>
                      <span class="setting-name" data-i18n="lbl_code">ä»£ç å—</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-code-block" checked>
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-code-block" class="fontsize-input" value="13" min="10" max="24">
                      px
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">âœ…</span>
                      <span class="setting-name" data-i18n="lbl_status">æ“ä½œçŠ¶æ€</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-action-status">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-action-status" class="fontsize-input" value="13" min="10"
                        max="24"> px
                    </div>
                  </div>

                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’­</span>
                      <span class="setting-name" data-i18n="lbl_thinking">æ€è€ƒè¿‡ç¨‹</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-fontsize-thinking">
                        <span class="toggle-slider"></span>
                      </label>
                      <input type="number" id="fontsize-thinking" class="fontsize-input" value="13" min="10" max="24">
                      px
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: LaTeX -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="latex_title">ğŸ“ LaTeX å…¬å¼</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_latex">å¯ç”¨ LaTeX æ¸²æŸ“</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="latex-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>
                <div class="setting-desc" data-i18n="latex_desc">è‡ªåŠ¨æ¸²æŸ“ AI å›å¤ä¸­çš„ LaTeX æ•°å­¦å…¬å¼</div>
                <div id="latex-status" class="save-status"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Tab: Features -->
        <div class="tab-content" id="tab-features">
          <!-- Accordion: Copy -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="copy_title">ğŸ“‹ ä¸€é”®å¤åˆ¶</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_copy">å¯ç”¨å¤åˆ¶æŒ‰é’®</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="copy-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="copy-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ“</span>
                      <span class="setting-name" data-i18n="lbl_user_msg">ç”¨æˆ·æ¶ˆæ¯</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-copy-user" checked>
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                  </div>
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ’­</span>
                      <span class="setting-name" data-i18n="lbl_thinking">æ€è€ƒè¿‡ç¨‹</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-copy-thinking" checked>
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                  </div>
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">ğŸ¤–</span>
                      <span class="setting-name" data-i18n="lbl_ai_resp">AIå›å¤</span>
                    </div>
                    <div class="setting-right">
                      <label class="toggle-switch">
                        <input type="checkbox" id="toggle-copy-ai" checked>
                        <span class="toggle-slider"></span>
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: Hotkeys -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="hotkey_title">âŒ¨ï¸ å¿«æ·é”®è®¾ç½®</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_hotkey">è‡ªå®šä¹‰å‘é€å¿«æ·é”®</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="hotkey-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div id="hotkey-settings">
                  <div class="setting-item">
                    <div class="setting-left">
                      <span class="setting-icon">â†µ</span>
                      <span class="setting-name" data-i18n="lbl_send_hotkey">å‘é€å¿«æ·é”®</span>
                    </div>
                    <div class="setting-right">
                      <select id="send-hotkey-select" class="select-input">
                        <option value="enter">Enter</option>
                        <option value="cmd+enter">âŒ˜ Cmd + Enter</option>
                        <option value="ctrl+enter">Ctrl + Enter</option>
                        <option value="shift+enter">â‡§ Shift + Enter</option>
                      </select>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>


          <!-- Accordion: Auto Accept -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="auto_accept_title">ğŸ¤– è‡ªåŠ¨æ“ä½œ</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="enable_auto_accept">å¯ç”¨è‡ªåŠ¨æ“ä½œ</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="auto-accept-master-toggle">
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div class="setting-desc" data-i18n="auto_accept_desc">é€‰æ‹©è¦è‡ªåŠ¨ç‚¹å‡»çš„æŒ‰é’®ç±»å‹</div>

                <div id="auto-accept-patterns" class="pattern-grid">
                  <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>

                <!-- ç»Ÿè®¡é¢æ¿ -->
                <div id="auto-accept-stats" class="stats-panel">
                  <div class="stat-item">
                    <span class="stat-icon">âœ…</span>
                    <span class="stat-value" id="stat-clicks">0</span>
                    <span class="stat-label" data-i18n="stat_clicks">å·²ç‚¹å‡»</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-icon">ğŸ›¡ï¸</span>
                    <span class="stat-value" id="stat-blocked">0</span>
                    <span class="stat-label" data-i18n="stat_blocked">å·²é˜»æ­¢</span>
                  </div>
                  <div class="stat-item">
                    <span class="stat-icon">âœ“</span>
                    <span class="stat-value" id="stat-verified">0</span>
                    <span class="stat-label" data-i18n="stat_verified">å·²éªŒè¯</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Accordion: Safety Rules -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="banned_title">ğŸ›¡ï¸ å®‰å…¨è§„åˆ™</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="setting-desc" data-i18n="banned_desc">åŒ…å«ä»¥ä¸‹å…³é”®è¯çš„å‘½ä»¤å°†ä¸ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰</div>
                <textarea id="banned-commands-input" class="banned-textarea" rows="6"></textarea>
                <div class="btn-group">
                  <button id="save-banned-btn" class="btn-action primary" data-i18n="btn_save">ä¿å­˜</button>
                  <button id="reset-banned-btn" class="btn-action secondary" data-i18n="btn_reset">é‡ç½®</button>
                </div>
                <div id="banned-save-status" class="save-status"></div>
              </div>
            </div>
          </div>

          <!-- Accordion: AI Translator -->
          <div class="accordion-item">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="translator_title">ğŸŒ AI Translator</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="main-toggle">
                  <span class="main-toggle-label" data-i18n="translator_enable">Enable Translator</span>
                  <label class="toggle-switch">
                    <input type="checkbox" id="translator-master-toggle" checked>
                    <span class="toggle-slider"></span>
                  </label>
                </div>

                <div class="setting-desc">
                  <span data-i18n="translator_desc">Provide your OpenRouter Key to enable translation.</span>
                  <br><span data-i18n="translator_bridge">Bridge Status</span>: <span id="bridge-status-indicator"
                    class="bridge-status" title="Connecting..."></span>
                </div>

                <div style="margin-top: 10px;">
                  <label class="setting-name">
                    <span data-i18n="translator_api_key">OpenRouter API Key (Stored securely)</span>
                    <span id="key-existence-status"
                      style="font-size: 10px; color: #4ADE80; font-weight: normal; margin-left: 8px; display: none;"
                      data-i18n="translator_key_configured">(âœ“ Key Configured)</span>
                  </label>
                  <div style="display: flex; gap: 6px; align-items: center;">
                    <input type="password" id="translator-key" class="translator-input" placeholder="sk-or-..."
                      style="flex: 1;">
                    <button type="button" id="toggle-key-visibility" class="btn-action"
                      style="padding: 6px 10px; font-size: 14px;" title="Show/Hide Key">ğŸ‘</button>
                  </div>
                  <button id="save-key-btn" class="btn-action primary" data-i18n="translator_save_key"
                    style="margin-top: 6px;">Save Key</button>
                  <div id="key-save-status" class="save-status"></div>
                </div>

                <div style="margin-top: 15px;">
                  <label class="setting-name" data-i18n="translator_model">Model</label>
                  <select id="translator-model" class="select-input" style="width: 100%;">
                    <optgroup label="ğŸ†“ Free Models" data-i18n-label="translator_free_models">
                      <option value="tngtech/deepseek-r1t2-chimera:free">DeepSeek R1T2 Chimera</option>
                      <option value="z-ai/glm-4.5-air:free">GLM 4.5 Air</option>
                      <option value="deepseek/deepseek-r1-0528:free">DeepSeek R1 0528</option>
                      <option value="nvidia/nemotron-3-nano-30b-a3b:free">Nemotron 3 Nano 30B</option>
                      <option value="allenai/molmo-2-8b:free">Molmo 2 8B</option>
                    </optgroup>
                    <optgroup label="ğŸ’° Budget (~$0.10-0.25/1M tokens)" data-i18n-label="translator_budget_models">
                      <option value="google/gemma-3-4b-it">Gemma 3 4B IT</option>
                      <option value="meta-llama/llama-3.1-8b-instruct">Llama 3.1 8B Instruct</option>
                      <option value="openai/gpt-oss-20b">GPT-OSS 20B</option>
                    </optgroup>
                    <optgroup label="ğŸ’µ Standard (~$0.25-1.00/1M tokens)" data-i18n-label="translator_standard_models">
                      <option value="mistralai/mistral-small-24b-instruct-2501">Mistral Small 24B</option>
                      <option value="anthropic/claude-3-haiku">Claude 3 Haiku</option>
                      <option value="openai/gpt-4o-mini">GPT-4o Mini</option>
                      <option value="google/gemini-2.5-flash-lite">Gemini 2.5 Flash Lite</option>
                    </optgroup>
                    <optgroup label="ğŸ’ Premium (~$1.00+/1M tokens)" data-i18n-label="translator_premium_models">
                      <option value="deepseek/deepseek-v3.2">DeepSeek V3.2</option>
                      <option value="x-ai/grok-4.1-fast">Grok 4.1 Fast</option>
                    </optgroup>
                    <optgroup label="âš™ï¸ Custom" data-i18n-label="translator_custom_models">
                      <option value="__custom__" data-i18n="translator_use_custom">Use Custom Model</option>
                    </optgroup>
                  </select>
                  <div id="custom-model-container" style="margin-top: 8px; display: none;">
                    <input type="text" id="translator-custom-model" class="translator-input"
                      placeholder="e.g. openai/gpt-4o" style="width: 100%; box-sizing: border-box;">
                    <div class="setting-desc" style="margin-top: 4px; font-size: 11px;"
                      data-i18n="translator_custom_hint">
                      Enter any valid OpenRouter model ID
                    </div>
                  </div>
                </div>

                <div style="margin-top: 10px;">
                  <label class="setting-name" data-i18n="translator_user_lang">Your Language (Input)</label>
                  <select id="translator-user-lang" class="select-input" style="width: 100%;">
                    <option value="Spanish">Spanish</option>
                    <option value="English">English</option>
                    <option value="Chinese">Chinese (Simplified)</option>
                    <option value="Japanese">Japanese</option>
                    <option value="French">French</option>
                    <option value="German">German</option>
                    <option value="Russian">Russian</option>
                    <option value="Korean">Korean</option>
                  </select>
                </div>

                <div style="margin-top: 10px;">
                  <label class="setting-name" data-i18n="translator_ai_lang">AI Language (Output)</label>
                  <select id="translator-ai-lang" class="select-input" style="width: 100%;">
                    <option value="English">English</option>
                    <option value="Spanish">Spanish</option>
                    <option value="Chinese">Chinese (Simplified)</option>
                    <option value="Japanese">Japanese</option>
                    <option value="French">French</option>
                    <option value="German">German</option>
                    <option value="Russian">Russian</option>
                    <option value="Korean">Korean</option>
                  </select>
                </div>
              </div>
            </div>
          </div>

        </div>

        <!-- Tab: System -->
        <div class="tab-content" id="tab-system">
          <!-- Accordion: Version Update -->
          <div class="accordion-item expanded">
            <div class="accordion-header">
              <span class="accordion-title" data-i18n="version_title">ğŸ”„ ç‰ˆæœ¬æ›´æ–°</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-inner">
                <div class="setting-item">
                  <div class="setting-left">
                    <span class="setting-icon">ğŸ”„</span>
                    <span class="setting-name" data-i18n="lbl_auto_update">å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹</span>
                  </div>
                  <div class="setting-right">
                    <label class="toggle-switch">
                      <input type="checkbox" id="auto-update-toggle" checked>
                      <span class="toggle-slider"></span>
                    </label>
                  </div>
                </div>

                <div class="setting-item">
                  <div class="setting-left">
                    <span class="setting-icon">ğŸ‘‰</span>
                    <span class="setting-name" data-i18n="lbl_manual_update">æ‰‹åŠ¨æ£€æµ‹æ›´æ–°</span>
                  </div>
                  <div class="setting-right">
                    <button id="manual-update-btn" class="btn-action primary" data-i18n="btn_check_update">ç«‹å³æ£€æµ‹</button>
                  </div>
                </div>

                <div id="update-status" class="save-status"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ===== I18N å­—å…¸ ===== */
    const TRANSLATIONS = {
      zh: {
        tab_appearance: 'ğŸ¨ å¤–è§‚',
        tab_features: 'ğŸ› ï¸ åŠŸèƒ½',
        colors_title: 'ğŸ¨ é¢œè‰²è‡ªå®šä¹‰',
        enable_custom_colors: 'å¯ç”¨è‡ªå®šä¹‰é¢œè‰²',
        lbl_user_msg: 'ç”¨æˆ·æ¶ˆæ¯',
        lbl_ai_resp: 'AIå›å¤',
        lbl_code: 'ä»£ç å—',
        lbl_status: 'æ“ä½œçŠ¶æ€',
        lbl_thinking: 'æ€è€ƒè¿‡ç¨‹',
        fontsize_title: 'ğŸ”¤ å­—ä½“å¤§å°',
        enable_custom_fontsize: 'å¯ç”¨è‡ªå®šä¹‰å­—ä½“å¤§å°',
        btn_sync: 'åŒæ­¥å…¨éƒ¨',
        update_available: 'æ–°ç‰ˆæœ¬å¯ç”¨',
        btn_download: 'ä¸‹è½½æ›´æ–°',
        copy_title: 'ğŸ“‹ ä¸€é”®å¤åˆ¶',
        enable_copy: 'å¯ç”¨å¤åˆ¶æŒ‰é’®',
        hotkey_title: 'âŒ¨ï¸ å¿«æ·é”®è®¾ç½®',
        enable_hotkey: 'è‡ªå®šä¹‰å‘é€å¿«æ·é”®',
        lbl_send_hotkey: 'å‘é€å¿«æ·é”®',
        auto_accept_title: 'ğŸ¤– è‡ªåŠ¨æ“ä½œ',
        enable_auto_accept: 'å¯ç”¨è‡ªåŠ¨æ“ä½œ',
        auto_accept_desc: 'é€‰æ‹©è¦è‡ªåŠ¨ç‚¹å‡»çš„æŒ‰é’®ç±»å‹',
        stat_clicks: 'å·²ç‚¹å‡»',
        stat_blocked: 'å·²é˜»æ­¢',
        stat_verified: 'å·²éªŒè¯',
        banned_title: 'ğŸ›¡ï¸ å®‰å…¨è§„åˆ™',
        banned_desc: 'åŒ…å«ä»¥ä¸‹å…³é”®è¯çš„å‘½ä»¤å°†ä¸ä¼šè¢«è‡ªåŠ¨æ‰§è¡Œï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰',
        btn_save: 'ä¿å­˜',
        btn_reset: 'é‡ç½®',
        banned_saved: 'âœ“ å®‰å…¨è§„åˆ™å·²ä¿å­˜',
        banned_reset: 'âœ“ å·²é‡ç½®ä¸ºé»˜è®¤å€¼',
        tab_system: 'âš™ï¸ ç³»ç»Ÿ',
        version_title: 'ğŸ”„ ç‰ˆæœ¬æ›´æ–°',
        lbl_auto_update: 'å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹',
        lbl_manual_update: 'æ‰‹åŠ¨æ£€æµ‹æ›´æ–°',
        btn_check_update: 'ç«‹å³æ£€æµ‹',
        update_checking: 'æ­£åœ¨æ£€æµ‹...',
        update_latest: 'âœ“ å·²æ˜¯æœ€æ–°ç‰ˆæœ¬',
        update_found: 'âœ“ å‘ç°æ–°ç‰ˆæœ¬',
        update_failed: 'âœ— æ£€æµ‹å¤±è´¥',
        latex_title: 'ğŸ“ LaTeX å…¬å¼',
        enable_latex: 'å¯ç”¨ LaTeX æ¸²æŸ“',
        latex_desc: 'è‡ªåŠ¨æ¸²æŸ“ AI å›å¤ä¸­çš„ LaTeX æ•°å­¦å…¬å¼',
        latex_loading: 'åŠ è½½ KaTeX åº“... cdn.jsdelivr.net',
        latex_ready: 'âœ“ KaTeX å·²å°±ç»ª',
        latex_failed: 'âœ— KaTeX åŠ è½½å¤±è´¥',
        // Translator
        translator_title: 'ğŸŒ AI ç¿»è¯‘å™¨',
        translator_enable: 'å¯ç”¨ç¿»è¯‘å™¨',
        translator_desc: 'æä¾›æ‚¨çš„ OpenRouter å¯†é’¥ä»¥å¯ç”¨ç¿»è¯‘åŠŸèƒ½ã€‚',
        translator_bridge: 'Bridge çŠ¶æ€',
        translator_api_key: 'OpenRouter API å¯†é’¥ï¼ˆå®‰å…¨å­˜å‚¨ï¼‰',
        translator_key_configured: '(âœ“ å¯†é’¥å·²é…ç½®)',
        translator_save_key: 'ä¿å­˜å¯†é’¥',
        translator_model: 'æ¨¡å‹',
        translator_user_lang: 'æ‚¨çš„è¯­è¨€ï¼ˆè¾“å…¥ï¼‰',
        translator_ai_lang: 'AI è¯­è¨€ï¼ˆè¾“å‡ºï¼‰',
        translator_select_text: 'è¯·é€‰æ‹©è¦ç¿»è¯‘çš„æ–‡æœ¬ï¼',
        translator_bridge_error: 'Bridge æœªè¿æ¥ï¼',
        translator_error: 'ç¿»è¯‘é”™è¯¯',
        translator_failed: 'ç¿»è¯‘å¤±è´¥',
        translator_copied: 'æ’å…¥å¤±è´¥ï¼Œå·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚',
        translator_key_saved: 'âœ“ å¯†é’¥å·²ä¿å­˜',
        translator_key_error: 'ä¿å­˜å¯†é’¥å¤±è´¥',
        translator_free_models: 'ğŸ†“ å…è´¹æ¨¡å‹',
        translator_budget_models: 'ğŸ’° ç»æµå‹',
        translator_standard_models: 'ğŸ’µ æ ‡å‡†å‹',
        translator_premium_models: 'ğŸ’ é«˜çº§å‹',
        translator_translating: 'ç¿»è¯‘ä¸­...',
        translator_custom_models: 'âš™ï¸ è‡ªå®šä¹‰',
        translator_use_custom: 'ä½¿ç”¨è‡ªå®šä¹‰æ¨¡å‹',
        translator_custom_hint: 'è¾“å…¥ä»»ä½•æœ‰æ•ˆçš„ OpenRouter æ¨¡å‹ ID'
      },
      en: {
        tab_appearance: 'ğŸ¨ Appearance',
        tab_features: 'ğŸ› ï¸ Features',
        colors_title: 'ğŸ¨ Colors',
        enable_custom_colors: 'Enable Custom Colors',
        lbl_user_msg: 'User Message',
        lbl_ai_resp: 'AI Response',
        lbl_code: 'Code Block',
        lbl_status: 'Action Status',
        lbl_thinking: 'Thinking Process',
        fontsize_title: 'ğŸ”¤ Font Size',
        enable_custom_fontsize: 'Enable Custom Font Size',
        btn_sync: 'Sync All',
        update_available: 'New version available',
        btn_download: 'Download',
        copy_title: 'ğŸ“‹ One-Click Copy',
        enable_copy: 'Enable Copy Buttons',
        hotkey_title: 'âŒ¨ï¸ Shortcuts',
        enable_hotkey: 'Custom Send Hotkey',
        lbl_send_hotkey: 'Send Hotkey',
        auto_accept_title: 'ğŸ¤– Auto Accept',
        enable_auto_accept: 'Enable Auto Accept',
        auto_accept_desc: 'Select button types to auto-click',
        stat_clicks: 'Clicked',
        stat_blocked: 'Blocked',
        stat_verified: 'Verified',
        banned_title: 'ğŸ›¡ï¸ Safety Rules',
        banned_desc: 'Commands containing these keywords will not be auto-executed (one per line)',
        btn_save: 'Save',
        btn_reset: 'Reset',
        banned_saved: 'âœ“ Safety rules saved',
        banned_reset: 'âœ“ Reset to defaults',
        tab_system: 'âš™ï¸ System',
        version_title: 'ğŸ”„ Version Update',
        lbl_auto_update: 'Auto check on startup',
        lbl_manual_update: 'Manual check',
        btn_check_update: 'Check Now',
        update_checking: 'Checking...',
        update_latest: 'âœ“ Already latest',
        update_found: 'âœ“ New version found',
        update_failed: 'âœ— Check failed',
        latex_title: 'ğŸ“ LaTeX Formulas',
        enable_latex: 'Enable LaTeX Rendering',
        latex_desc: 'Auto-render LaTeX math formulas in AI responses',
        latex_loading: 'Loading KaTeX... cdn.jsdelivr.net',
        latex_ready: 'âœ“ KaTeX Ready',
        latex_failed: 'âœ— KaTeX Load Failed',
        // Translator
        translator_title: 'ğŸŒ AI Translator',
        translator_enable: 'Enable Translator',
        translator_desc: 'Provide your OpenRouter Key to enable translation.',
        translator_bridge: 'Bridge Status',
        translator_api_key: 'OpenRouter API Key (Stored securely)',
        translator_key_configured: '(âœ“ Key Configured)',
        translator_save_key: 'Save Key',
        translator_model: 'Model',
        translator_user_lang: 'Your Language (Input)',
        translator_ai_lang: 'AI Language (Output)',
        translator_select_text: 'Please select some text to translate!',
        translator_bridge_error: 'Bridge not connected!',
        translator_error: 'Translation Error',
        translator_failed: 'Translation Failed',
        translator_copied: 'Insert failed. Copied to clipboard.',
        translator_key_saved: 'âœ“ Key Saved',
        translator_key_error: 'Failed to save key',
        translator_free_models: 'ğŸ†“ Free Models',
        translator_budget_models: 'ğŸ’° Budget',
        translator_standard_models: 'ğŸ’µ Standard',
        translator_premium_models: 'ğŸ’ Premium',
        translator_translating: 'Translating...',
        translator_custom_models: 'âš™ï¸ Custom',
        translator_use_custom: 'Use Custom Model',
        translator_custom_hint: 'Enter any valid OpenRouter model ID'
      }
    };

    /* ===== ç‰ˆæœ¬æ£€æµ‹é…ç½® ===== */
    const APP_VERSION = '0.1.7';
    const VERSION_API = 'https://hub.lib00.com/api/v1/antigravity-better/version';

    /* ===== Translator Constants ===== */
    const DEFAULT_TRANSLATOR_MODEL = 'tngtech/deepseek-r1t2-chimera:free';

    // Helper: Get currently selected translator model (handles custom model)
    function getSelectedModel() {
      const modelSelect = document.getElementById('translator-model');
      let model = modelSelect?.value || DEFAULT_TRANSLATOR_MODEL;
      if (model === '__custom__') {
        const customInput = document.getElementById('translator-custom-model');
        model = customInput?.value?.trim() || DEFAULT_TRANSLATOR_MODEL;
      }
      return model;
    }


    // è¯­ä¹‰åŒ–ç‰ˆæœ¬æ¯”è¾ƒï¼šremote > local è¿”å› true
    function isNewerVersion(remote, local) {
      const r = remote.replace(/^v/i, '').split('.').map(Number);
      const l = local.replace(/^v/i, '').split('.').map(Number);
      for (let i = 0; i < Math.max(r.length, l.length); i++) {
        if ((r[i] || 0) > (l[i] || 0)) return true;
        if ((r[i] || 0) < (l[i] || 0)) return false;
      }
      return false;
    }

    // æ˜¾ç¤ºæ›´æ–°æç¤º
    function showUpdateBanner(newVersion, downloadUrl) {
      const banner = document.getElementById('update-banner');
      const versionSpan = document.getElementById('new-version');
      const downloadBtn = banner ? banner.querySelector('.update-btn') : null;
      if (banner && versionSpan) {
        versionSpan.textContent = 'v' + newVersion;
        if (downloadUrl && downloadBtn) downloadBtn.href = downloadUrl;
        banner.classList.add('show');
      }
    }

    // éšè—æ›´æ–°æç¤º
    function hideUpdateBanner() {
      const banner = document.getElementById('update-banner');
      if (banner) banner.classList.remove('show');
    }

    // ç»‘å®šå…³é—­æŒ‰é’®äº‹ä»¶
    document.getElementById('update-close-btn').addEventListener('click', hideUpdateBanner);

    // æ£€æµ‹æ›´æ–° (è¿”å›: 'found' | 'latest' | 'error')
    async function checkForUpdate() {
      try {
        const response = await fetch(VERSION_API, { cache: 'no-store' });
        if (!response.ok) return 'error';
        const json = await response.json();
        const data = json.data || json; // æ”¯æŒ { data: {...} } æˆ–ç›´æ¥ {...}
        const remoteVersion = data.version;
        if (remoteVersion && isNewerVersion(remoteVersion, APP_VERSION)) {
          showUpdateBanner(remoteVersion, data.url);
          return 'found';
        }
        return 'latest';
      } catch (e) {
        console.log('[VersionCheck] Failed:', e.message);
        return 'error';
      }
    }

    // æ‰‹åŠ¨æ£€æµ‹æ›´æ–° (å¸¦ UI åé¦ˆ)
    async function manualCheckUpdate() {
      const statusEl = document.getElementById('update-status');
      const btn = document.getElementById('manual-update-btn');
      const dict = TRANSLATIONS[currentSettings.lang];

      if (statusEl) statusEl.textContent = dict.update_checking;
      if (btn) btn.disabled = true;

      const result = await checkForUpdate();

      if (statusEl) {
        if (result === 'found') statusEl.textContent = dict.update_found;
        else if (result === 'latest') statusEl.textContent = dict.update_latest;
        else statusEl.textContent = dict.update_failed;
        setTimeout(() => { statusEl.textContent = ''; }, 3000);
      }
      if (btn) btn.disabled = false;
    }

    /* ===== æ—¢å­˜é…ç½®é€»è¾‘ ===== */
    const STORAGE_KEY = 'cascade-panel-settings';

    // é¢œè‰²é…ç½®
    const COLOR_CONFIGS = [
      { id: 'user-message', cssVar: '--color-user-message', cssClass: 'color-user-message', default: '#60A5FA', enabled: true },
      { id: 'ai-response', cssVar: '--color-ai-response', cssClass: 'color-ai-response', default: '#E0E0E0', enabled: true },
      { id: 'code-block', cssVar: '--color-code-block', cssClass: 'color-code-block', default: '#A78BFA', enabled: true },
      { id: 'action-status', cssVar: '--color-action-status', cssClass: 'color-action-status', default: '#4ADE80', enabled: false },
      { id: 'thinking', cssVar: '--color-thinking', cssClass: 'color-thinking', default: '#9CA3AF', enabled: false },
    ];

    // å­—ä½“å¤§å°é…ç½®
    const FONTSIZE_CONFIGS = [
      { id: 'user-message', cssVar: '--fontsize-user-message', cssClass: 'fontsize-user-message', default: 14, enabled: true },
      { id: 'ai-response', cssVar: '--fontsize-ai-response', cssClass: 'fontsize-ai-response', default: 14, enabled: true },
      { id: 'code-block', cssVar: '--fontsize-code-block', cssClass: 'fontsize-code-block', default: 13, enabled: true },
      { id: 'action-status', cssVar: '--fontsize-action-status', cssClass: 'fontsize-action-status', default: 13, enabled: false },
      { id: 'thinking', cssVar: '--fontsize-thinking', cssClass: 'fontsize-thinking', default: 13, enabled: false },
    ];

    // å¤åˆ¶é…ç½®
    const COPY_CONFIGS = [
      { id: 'copy-user', selector: '.bg-gray-500\\/15', textSelector: '.whitespace-pre-wrap', type: 'user' },
      { id: 'copy-thinking', selector: '.opacity-70.prose', textSelector: null, type: 'thinking' },
      { id: 'copy-ai', selector: '.prose:not(.opacity-70)', textSelector: null, type: 'ai' },
    ];

    // å¿«æ·é”®é€‰é¡¹
    const HOTKEY_OPTIONS = [
      { id: 'enter', label: 'Enter', check: (e) => e.key === 'Enter' && !e.metaKey && !e.ctrlKey && !e.shiftKey },
      { id: 'cmd+enter', label: 'âŒ˜ Cmd + Enter', check: (e) => e.key === 'Enter' && e.metaKey },
      { id: 'ctrl+enter', label: 'Ctrl + Enter', check: (e) => e.key === 'Enter' && e.ctrlKey },
      { id: 'shift+enter', label: 'â‡§ Shift + Enter', check: (e) => e.key === 'Enter' && e.shiftKey },
    ];

    // è‡ªåŠ¨æ“ä½œæŒ‰é’®é…ç½® - æ¯ä¸ªç±»å‹å¯ç‹¬ç«‹å¼€å…³
    const AUTO_ACCEPT_CONFIGS = [
      { id: 'accept', label: 'Accept', defaultEnabled: false },
      { id: 'retry', label: 'Retry', defaultEnabled: true },
      { id: 'run', label: 'Run', defaultEnabled: true },
      { id: 'apply', label: 'Apply', defaultEnabled: true },
      { id: 'execute', label: 'Execute', defaultEnabled: true },
      { id: 'confirm', label: 'Confirm', defaultEnabled: true },
      { id: 'allow', label: 'Allow', defaultEnabled: true },
    ];

    // å±é™©å‘½ä»¤é»˜è®¤é»‘åå•
    const DEFAULT_BANNED_COMMANDS = [
      'rm -rf /',
      'rm -rf ~',
      'rm -rf *',
      'format c:',
      'del /f /s /q',
      'rmdir /s /q',
      ':(){:|:&};:',
      'dd if=',
      'mkfs.',
      '> /dev/sda',
      'chmod -R 777 /'
    ];

    const defaultSettings = {
      lang: 'zh',
      masterEnabled: false,
      colors: COLOR_CONFIGS.reduce((acc, c) => { acc[c.id] = { color: c.default, enabled: c.enabled }; return acc; }, {}),
      // å­—ä½“å¤§å°è®¾ç½®
      fontsizeMasterEnabled: false,
      fontsizes: FONTSIZE_CONFIGS.reduce((acc, c) => { acc[c.id] = { size: c.default, enabled: c.enabled }; return acc; }, {}),
      copyEnabled: false,
      copy: COPY_CONFIGS.reduce((acc, c) => { acc[c.id] = { enabled: true }; return acc; }, {}),
      hotkeyEnabled: false,
      sendHotkey: 'cmd+enter',
      // è‡ªåŠ¨æ“ä½œé…ç½®
      autoAcceptEnabled: false,
      autoAcceptPatterns: AUTO_ACCEPT_CONFIGS.reduce((acc, c) => { acc[c.id] = c.defaultEnabled; return acc; }, {}),
      bannedCommands: [...DEFAULT_BANNED_COMMANDS],
      // ç»Ÿè®¡æ•°æ®
      autoAcceptStats: { clicks: 0, blocked: 0, verified: 0 },
      // ç³»ç»Ÿè®¾ç½®
      autoUpdateEnabled: true,
      // LaTeX æ¸²æŸ“è®¾ç½®
      latexEnabled: false,
      // Translator è®¾ç½®
      translatorEnabled: true,
      translatorModel: 'tngtech/deepseek-r1t2-chimera:free',
      translatorUserLang: 'Spanish',
      translatorAiLang: 'English',
      translatorCustomModel: ''
    };

    function loadSettings() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          return {
            lang: parsed.lang ?? defaultSettings.lang,
            masterEnabled: parsed.masterEnabled ?? defaultSettings.masterEnabled,
            colors: { ...defaultSettings.colors, ...parsed.colors },
            fontsizeMasterEnabled: parsed.fontsizeMasterEnabled ?? defaultSettings.fontsizeMasterEnabled,
            fontsizes: { ...defaultSettings.fontsizes, ...parsed.fontsizes },
            copyEnabled: parsed.copyEnabled ?? defaultSettings.copyEnabled,
            copy: { ...defaultSettings.copy, ...parsed.copy },
            hotkeyEnabled: parsed.hotkeyEnabled ?? defaultSettings.hotkeyEnabled,
            sendHotkey: parsed.sendHotkey ?? defaultSettings.sendHotkey,
            // è‡ªåŠ¨æ“ä½œé…ç½®
            autoAcceptEnabled: parsed.autoAcceptEnabled ?? defaultSettings.autoAcceptEnabled,
            autoAcceptPatterns: { ...defaultSettings.autoAcceptPatterns, ...parsed.autoAcceptPatterns },
            bannedCommands: parsed.bannedCommands ?? [...DEFAULT_BANNED_COMMANDS],
            autoAcceptStats: { ...defaultSettings.autoAcceptStats, ...parsed.autoAcceptStats },
            autoUpdateEnabled: parsed.autoUpdateEnabled ?? defaultSettings.autoUpdateEnabled,
            latexEnabled: parsed.latexEnabled ?? defaultSettings.latexEnabled,
            translatorEnabled: parsed.translatorEnabled ?? defaultSettings.translatorEnabled,
            translatorModel: parsed.translatorModel ?? defaultSettings.translatorModel,
            translatorUserLang: parsed.translatorUserLang ?? defaultSettings.translatorUserLang,
            translatorAiLang: parsed.translatorAiLang ?? defaultSettings.translatorAiLang,
            translatorCustomModel: parsed.translatorCustomModel ?? defaultSettings.translatorCustomModel
          };
        }
        return { ...defaultSettings };
      } catch (e) { return { ...defaultSettings }; }
    }

    function saveSettings(settings) {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch (e) { console.warn('Save failed:', e); }
    }

    /* ===== DOM å…ƒç´  ===== */
    const settingsBtn = document.getElementById('settings-toggle-btn');
    const overlay = document.getElementById('settings-overlay');
    const closeBtn = document.getElementById('modal-close-btn');
    const langSwitch = document.getElementById('lang-switch');
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    const accordionHeaders = document.querySelectorAll('.accordion-header');

    // æ§ä»¶å¼•ç”¨
    const masterToggle = document.getElementById('master-toggle');
    const copyMasterToggle = document.getElementById('copy-master-toggle');
    const hotkeyMasterToggle = document.getElementById('hotkey-master-toggle');
    const fontsizeMasterToggle = document.getElementById('fontsize-master-toggle');
    const sendHotkeySelect = document.getElementById('send-hotkey-select');
    const reactApp = document.getElementById('react-app');

    // è‡ªåŠ¨æ“ä½œæ§ä»¶å¼•ç”¨
    const autoAcceptMasterToggle = document.getElementById('auto-accept-master-toggle');
    const autoAcceptPatternsContainer = document.getElementById('auto-accept-patterns');
    const bannedCommandsInput = document.getElementById('banned-commands-input');
    const saveBannedBtn = document.getElementById('save-banned-btn');
    const resetBannedBtn = document.getElementById('reset-banned-btn');
    const bannedSaveStatus = document.getElementById('banned-save-status');
    const statClicksEl = document.getElementById('stat-clicks');
    const statBlockedEl = document.getElementById('stat-blocked');
    const statVerifiedEl = document.getElementById('stat-verified');

    // LaTeX æ§ä»¶å¼•ç”¨
    const latexMasterToggle = document.getElementById('latex-master-toggle');
    const latexStatusEl = document.getElementById('latex-status');

    /* ===== äº¤äº’é€»è¾‘ ===== */
    let currentSettings = loadSettings();

    // 1. è¯­è¨€åˆ‡æ¢
    function updateLanguage() {
      const lang = currentSettings.lang;
      const dict = TRANSLATIONS[lang];
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (dict[key]) el.textContent = dict[key];
      });
      // Also translate optgroup labels
      document.querySelectorAll('[data-i18n-label]').forEach(el => {
        const key = el.getAttribute('data-i18n-label');
        if (dict[key]) el.setAttribute('label', dict[key]);
      });
      // SVG flags that render in any environment
      const usFlag = `<svg viewBox="0 0 7410 3900" style="width:16px;height:11px;flex-shrink:0;border-radius:2px;box-shadow:0 0 2px rgba(0,0,0,0.3)"><rect fill="#b22234" width="7410" height="3900"/><path d="M0,450H7410m0,600H0m0,600H7410m0,600H0m0,600H7410m0,600H0" stroke="#fff" stroke-width="300"/><rect fill="#3c3b6e" width="2964" height="2100"/></svg>`;
      const cnFlag = `<svg viewBox="0 0 30 20" style="width:16px;height:11px;flex-shrink:0;border-radius:2px;box-shadow:0 0 2px rgba(0,0,0,0.3)"><rect fill="#de2910" width="30" height="20"/><g fill="#ffde00"><polygon points="5,4 5.59,5.81 7.47,5.81 5.94,6.95 6.53,8.76 5,7.62 3.47,8.76 4.06,6.95 2.53,5.81 4.41,5.81"/><polygon points="10,1.5 10.3,2.43 11.27,2.43 10.48,3.01 10.79,3.94 10,3.35 9.21,3.94 9.52,3.01 8.73,2.43 9.7,2.43"/><polygon points="12,4 12.3,4.93 13.27,4.93 12.48,5.51 12.79,6.44 12,5.85 11.21,6.44 11.52,5.51 10.73,4.93 11.7,4.93"/><polygon points="12,7 12.3,7.93 13.27,7.93 12.48,8.51 12.79,9.44 12,8.85 11.21,9.44 11.52,8.51 10.73,7.93 11.7,7.93"/><polygon points="10,9.5 10.3,10.43 11.27,10.43 10.48,11.01 10.79,11.94 10,11.35 9.21,11.94 9.52,11.01 8.73,10.43 9.7,10.43"/></g></svg>`;
      const flagText = lang === 'zh' ? usFlag + '<span style="margin-left:6px">English</span>' : cnFlag + '<span style="margin-left:6px">ä¸­æ–‡</span>';
      langSwitch.innerHTML = `<span style="display:inline-flex;align-items:center">${flagText}</span>`;
    }

    langSwitch.addEventListener('click', () => {
      currentSettings.lang = currentSettings.lang === 'zh' ? 'en' : 'zh';
      saveSettings(currentSettings);
      updateLanguage();
    });

    // 2. Tab åˆ‡æ¢
    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        tabBtns.forEach(b => b.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));

        btn.classList.add('active');
        const tabId = `tab-${btn.dataset.tab}`;
        document.getElementById(tabId).classList.add('active');
      });
    });

    // 3. æ‰‹é£ç´é€»è¾‘
    accordionHeaders.forEach(header => {
      header.addEventListener('click', () => {
        const item = header.parentElement;
        item.classList.toggle('expanded');
      });
    });

    // 4. å¼¹çª—æ§åˆ¶
    function openModal() {
      overlay.classList.add('show');
      requestAnimationFrame(() => overlay.classList.add('visible'));
    }
    function closeModal() {
      overlay.classList.remove('visible');
      setTimeout(() => overlay.classList.remove('show'), 300);
    }
    settingsBtn.addEventListener('click', openModal);
    closeBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', (e) => { if (e.target === overlay) closeModal(); });

    /* ===== åŠŸèƒ½å®ç° ===== */
    // A. é¢œè‰²åŠŸèƒ½
    function applyColorSettings() {
      COLOR_CONFIGS.forEach(config => {
        const colorSetting = currentSettings.colors[config.id];
        document.documentElement.style.setProperty(config.cssVar, colorSetting.color);
        if (currentSettings.masterEnabled && colorSetting.enabled) {
          reactApp.classList.add(config.cssClass);
        } else {
          reactApp.classList.remove(config.cssClass);
        }
      });
    }

    masterToggle.addEventListener('change', () => {
      currentSettings.masterEnabled = masterToggle.checked;
      saveSettings(currentSettings);
      applyColorSettings();
    });

    COLOR_CONFIGS.forEach(config => {
      const toggleEl = document.getElementById(`toggle-${config.id}`);
      const colorEl = document.getElementById(`color-${config.id}`);

      if (toggleEl) {
        toggleEl.addEventListener('change', () => {
          currentSettings.colors[config.id].enabled = toggleEl.checked;
          saveSettings(currentSettings);
          applyColorSettings();
        });
      }
      if (colorEl) {
        colorEl.addEventListener('input', () => {
          currentSettings.colors[config.id].color = colorEl.value;
          saveSettings(currentSettings);
          applyColorSettings();
        });
      }
    });

    // A2. å­—ä½“å¤§å°åŠŸèƒ½
    function applyFontsizeSettings() {
      FONTSIZE_CONFIGS.forEach(config => {
        const fontSetting = currentSettings.fontsizes[config.id];
        document.documentElement.style.setProperty(config.cssVar, fontSetting.size + 'px');
        if (currentSettings.fontsizeMasterEnabled && fontSetting.enabled) {
          reactApp.classList.add(config.cssClass);
        } else {
          reactApp.classList.remove(config.cssClass);
        }
      });
    }

    fontsizeMasterToggle.addEventListener('change', () => {
      currentSettings.fontsizeMasterEnabled = fontsizeMasterToggle.checked;
      saveSettings(currentSettings);
      applyFontsizeSettings();
    });

    FONTSIZE_CONFIGS.forEach(config => {
      const toggleEl = document.getElementById(`toggle-fontsize-${config.id}`);
      const sizeEl = document.getElementById(`fontsize-${config.id}`);

      if (toggleEl) {
        toggleEl.addEventListener('change', () => {
          currentSettings.fontsizes[config.id].enabled = toggleEl.checked;
          saveSettings(currentSettings);
          applyFontsizeSettings();
        });
      }
      if (sizeEl) {
        sizeEl.addEventListener('input', () => {
          const val = parseInt(sizeEl.value) || config.default;
          currentSettings.fontsizes[config.id].size = Math.max(10, Math.min(24, val));
          saveSettings(currentSettings);
          applyFontsizeSettings();
        });
      }
    });

    // ä¸€é”®åŒæ­¥å­—ä½“å¤§å°æŒ‰é’®
    document.getElementById('fontsize-sync-btn').addEventListener('click', () => {
      const baseSize = currentSettings.fontsizes['user-message'].size;
      FONTSIZE_CONFIGS.forEach(config => {
        currentSettings.fontsizes[config.id].size = baseSize;
        const sizeEl = document.getElementById(`fontsize-${config.id}`);
        if (sizeEl) sizeEl.value = baseSize;
      });
      saveSettings(currentSettings);
      applyFontsizeSettings();
    });

    // B. å¤åˆ¶åŠŸèƒ½
    let copyObserver = null;
    const COPY_ICON = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>';
    const CHECK_ICON = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>';

    function copyToClipboard(text) {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      textarea.select();
      let success = false;
      try { success = document.execCommand('copy'); } catch (err) { }
      document.body.removeChild(textarea);
      return success;
    }

    function createCopyButton(targetEl, getText) {
      const btn = document.createElement('button');
      btn.className = 'copy-btn';
      btn.innerHTML = COPY_ICON;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        e.preventDefault();
        const success = copyToClipboard(getText());
        if (success) {
          btn.innerHTML = CHECK_ICON;
          btn.classList.add('copied');
          setTimeout(() => {
            btn.innerHTML = COPY_ICON;
            btn.classList.remove('copied');
          }, 1500);
        }
      });
      return btn;
    }

    function injectCopyButtons() {
      if (!currentSettings.copyEnabled) return;
      COPY_CONFIGS.forEach(config => {
        if (!currentSettings.copy[config.id]?.enabled) return;
        const elements = reactApp.querySelectorAll(config.selector);
        elements.forEach(el => {
          if (el.querySelector('.copy-btn') || el.closest('#settings-overlay')) return;
          el.classList.add('copy-target');
          const getText = () => config.textSelector ? (el.querySelector(config.textSelector)?.textContent || el.textContent) : el.textContent;
          el.appendChild(createCopyButton(el, getText));
        });
      });
    }

    function removeCopyButtons() {
      reactApp.querySelectorAll('.copy-btn').forEach(btn => btn.remove());
      reactApp.querySelectorAll('.copy-target').forEach(el => el.classList.remove('copy-target'));
    }

    function applyCopySettings() {
      if (currentSettings.copyEnabled) {
        if (!copyObserver) {
          copyObserver = new MutationObserver(() => setTimeout(injectCopyButtons, 100));
          copyObserver.observe(reactApp, { childList: true, subtree: true });
          injectCopyButtons();
        }
      } else {
        if (copyObserver) { copyObserver.disconnect(); copyObserver = null; }
        removeCopyButtons();
      }
    }

    copyMasterToggle.addEventListener('change', () => {
      currentSettings.copyEnabled = copyMasterToggle.checked;
      saveSettings(currentSettings);
      applyCopySettings();
    });

    COPY_CONFIGS.forEach(config => {
      const toggleEl = document.getElementById(`toggle-${config.id}`);
      if (toggleEl) {
        toggleEl.addEventListener('change', () => {
          currentSettings.copy[config.id].enabled = toggleEl.checked;
          saveSettings(currentSettings);
          removeCopyButtons();
          if (currentSettings.copyEnabled) injectCopyButtons();
        });
      }
    });

    // C. å¿«æ·é”®åŠŸèƒ½
    let hotkeyHandler = null;
    const INPUT_SELECTOR = 'div[contenteditable="true"][data-lexical-editor="true"]';
    const SEND_BTN_SELECTOR = 'button[data-tooltip-id="input-send-button-send-tooltip"]';

    function createHotkeyHandler() {
      const selected = currentSettings.sendHotkey;
      const config = HOTKEY_OPTIONS.find(h => h.id === selected);
      return function (e) {
        const inputEl = e.target.closest(INPUT_SELECTOR);
        if (!inputEl || e.key !== 'Enter') return;

        // æ£€æŸ¥ä¸‹æ‹‰èœå•
        if (inputEl.hasAttribute('aria-activedescendant') ||
          (document.querySelector('.lexical-typeahead-menu') && document.querySelector('.lexical-typeahead-menu').style.display !== 'none')) {
          return;
        }

        if (config && config.check(e)) {
          e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
          const sendBtn = document.querySelector(SEND_BTN_SELECTOR);
          if (sendBtn) {
            sendBtn.click();
          }
        } else if (e.key === 'Enter') {
          // é˜»æ­¢é»˜è®¤å‘é€ (é™¤éshift+enter)
          if (!e.shiftKey || selected === 'shift+enter') {
            e.stopPropagation(); e.stopImmediatePropagation();
          }
        }
      };
    }

    function applyHotkeySettings() {
      if (hotkeyHandler) { document.removeEventListener('keydown', hotkeyHandler, { capture: true }); hotkeyHandler = null; }
      if (currentSettings.hotkeyEnabled) {
        hotkeyHandler = createHotkeyHandler();
        document.addEventListener('keydown', hotkeyHandler, { capture: true });
      }
    }

    hotkeyMasterToggle.addEventListener('change', () => {
      currentSettings.hotkeyEnabled = hotkeyMasterToggle.checked;
      saveSettings(currentSettings);
      applyHotkeySettings();
    });

    sendHotkeySelect.addEventListener('change', () => {
      currentSettings.sendHotkey = sendHotkeySelect.value;
      saveSettings(currentSettings);
      if (currentSettings.hotkeyEnabled) applyHotkeySettings();
    });


    /* ===== E. è‡ªåŠ¨æ“ä½œåŠŸèƒ½ ===== */
    let autoAcceptObserver = null;

    // æ›´æ–°ç»Ÿè®¡é¢æ¿
    function updateStatsUI() {
      if (statClicksEl) statClicksEl.textContent = currentSettings.autoAcceptStats.clicks;
      if (statBlockedEl) statBlockedEl.textContent = currentSettings.autoAcceptStats.blocked;
      if (statVerifiedEl) statVerifiedEl.textContent = currentSettings.autoAcceptStats.verified;
    }

    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    function updateStats(delta) {
      if (delta.clicks) currentSettings.autoAcceptStats.clicks += delta.clicks;
      if (delta.blocked) currentSettings.autoAcceptStats.blocked += delta.blocked;
      if (delta.verified) currentSettings.autoAcceptStats.verified += delta.verified;
      saveSettings(currentSettings);
      updateStatsUI();
    }

    // æ¸²æŸ“æŒ‰é’®ç±»å‹ checkbox
    function renderPatternCheckboxes() {
      if (!autoAcceptPatternsContainer) return;
      autoAcceptPatternsContainer.innerHTML = '';

      AUTO_ACCEPT_CONFIGS.forEach(config => {
        const isEnabled = currentSettings.autoAcceptPatterns[config.id];
        const label = document.createElement('label');
        label.className = `pattern-item${isEnabled ? ' active' : ''}`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = isEnabled;
        checkbox.addEventListener('change', () => {
          currentSettings.autoAcceptPatterns[config.id] = checkbox.checked;
          label.classList.toggle('active', checkbox.checked);
          saveSettings(currentSettings);
        });

        const text = document.createElement('span');
        text.textContent = config.label;

        label.appendChild(checkbox);
        label.appendChild(text);
        autoAcceptPatternsContainer.appendChild(label);
      });
    }

    // åˆ¤æ–­æŒ‰é’®æ˜¯å¦ä¸ºè‡ªåŠ¨æ¥å—ç›®æ ‡
    function isAutoAcceptButton(el) {
      const text = (el.textContent || '').trim().toLowerCase();
      if (text.length === 0 || text.length > 50) return false;

      // è·å–å¯ç”¨çš„æŒ‰é’®æ¨¡å¼
      const patterns = Object.entries(currentSettings.autoAcceptPatterns)
        .filter(([_, enabled]) => enabled)
        .map(([pattern, _]) => pattern);

      if (patterns.length === 0) return false;

      // æ’é™¤è¯
      const rejects = ['skip', 'reject', 'cancel', 'close', 'refine', 'dismiss'];
      if (rejects.some(r => text.includes(r))) return false;

      // åŒ¹é…å¯ç”¨çš„æ¨¡å¼
      if (!patterns.some(p => text.includes(p))) return false;

      // æ£€æŸ¥å¯è§æ€§
      const style = window.getComputedStyle(el);
      const rect = el.getBoundingClientRect();
      return style.display !== 'none' && rect.width > 0 && !el.disabled;
    }

    // ä»æŒ‰é’®é™„è¿‘æå–å‘½ä»¤æ–‡æœ¬
    function findNearbyCommandText(buttonEl) {
      let commandText = '';
      let container = buttonEl.parentElement;
      let depth = 0;

      while (container && depth < 10) {
        let sibling = container.previousElementSibling;
        let siblingCount = 0;

        while (sibling && siblingCount < 5) {
          if (sibling.tagName === 'PRE' || sibling.tagName === 'CODE') {
            commandText += ' ' + sibling.textContent.trim();
          }
          const codeEls = sibling.querySelectorAll('pre, code');
          codeEls.forEach(el => {
            if (el.textContent) commandText += ' ' + el.textContent.trim();
          });
          sibling = sibling.previousElementSibling;
          siblingCount++;
        }

        if (commandText.length > 10) break;
        container = container.parentElement;
        depth++;
      }

      return commandText.trim().toLowerCase();
    }

    // æ£€æŸ¥å‘½ä»¤æ˜¯å¦åœ¨é»‘åå•ä¸­
    function isCommandBanned(commandText) {
      const bannedList = currentSettings.bannedCommands || [];
      if (!commandText || bannedList.length === 0) return false;

      const lowerText = commandText.toLowerCase();
      return bannedList.some(pattern => {
        if (!pattern) return false;
        return lowerText.includes(pattern.toLowerCase());
      });
    }

    // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§
    function isElementVisible(el) {
      if (!el || !el.isConnected) return false;
      const style = window.getComputedStyle(el);
      const rect = el.getBoundingClientRect();
      return style.display !== 'none' && rect.width > 0;
    }

    // ç­‰å¾…å…ƒç´ æ¶ˆå¤±ï¼ˆéªŒè¯ç‚¹å‡»æˆåŠŸï¼‰
    function waitForDisappear(el, timeout = 500) {
      return new Promise(resolve => {
        const startTime = Date.now();
        const check = () => {
          if (!isElementVisible(el)) {
            resolve(true);
          } else if (Date.now() - startTime >= timeout) {
            resolve(false);
          } else {
            requestAnimationFrame(check);
          }
        };
        setTimeout(check, 50);
      });
    }

    // æ‰§è¡Œè‡ªåŠ¨æ“ä½œ
    async function performAutoAccept() {
      if (!currentSettings.autoAcceptEnabled) return;

      const buttons = reactApp.querySelectorAll('button');

      for (const btn of buttons) {
        if (!isAutoAcceptButton(btn)) continue;

        const buttonText = (btn.textContent || '').trim().toLowerCase();

        // æ£€æŸ¥æ˜¯å¦ä¸ºå‘½ä»¤æ‰§è¡ŒæŒ‰é’®
        if (/run|execute/i.test(buttonText)) {
          const nearbyText = findNearbyCommandText(btn);
          if (isCommandBanned(nearbyText)) {
            console.log('[AutoAccept] Blocked dangerous command:', nearbyText.substring(0, 50));
            updateStats({ blocked: 1 });
            continue;
          }
        }

        // æ‰§è¡Œç‚¹å‡»
        btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
        updateStats({ clicks: 1 });

        // éªŒè¯ç‚¹å‡»
        const disappeared = await waitForDisappear(btn);
        if (disappeared) {
          updateStats({ verified: 1 });
        }

        // é˜²æ­¢è¿ç»­ç‚¹å‡»å¤ªå¿«
        await new Promise(r => setTimeout(r, 100));
      }
    }

    // åº”ç”¨è‡ªåŠ¨æ“ä½œè®¾ç½®
    function applyAutoAcceptSettings() {
      if (autoAcceptObserver) {
        autoAcceptObserver.disconnect();
        autoAcceptObserver = null;
      }

      if (currentSettings.autoAcceptEnabled) {
        autoAcceptObserver = new MutationObserver(() => {
          clearTimeout(window.autoAcceptThrottleTimer);
          window.autoAcceptThrottleTimer = setTimeout(performAutoAccept, 500);
        });
        autoAcceptObserver.observe(reactApp, { childList: true, subtree: true });
        performAutoAccept(); // åˆå§‹æ‰§è¡Œä¸€æ¬¡
      }
    }

    // è‡ªåŠ¨æ“ä½œä¸»å¼€å…³äº‹ä»¶
    if (autoAcceptMasterToggle) {
      autoAcceptMasterToggle.addEventListener('change', () => {
        currentSettings.autoAcceptEnabled = autoAcceptMasterToggle.checked;
        saveSettings(currentSettings);
        applyAutoAcceptSettings();
      });
    }

    // å±é™©å‘½ä»¤ä¿å­˜æŒ‰é’®
    if (saveBannedBtn) {
      saveBannedBtn.addEventListener('click', () => {
        const lines = bannedCommandsInput.value.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        currentSettings.bannedCommands = lines;
        saveSettings(currentSettings);
        if (bannedSaveStatus) {
          bannedSaveStatus.textContent = TRANSLATIONS[currentSettings.lang].banned_saved;
          setTimeout(() => { bannedSaveStatus.textContent = ''; }, 3000);
        }
      });
    }

    // å±é™©å‘½ä»¤é‡ç½®æŒ‰é’®
    if (resetBannedBtn) {
      resetBannedBtn.addEventListener('click', () => {
        currentSettings.bannedCommands = [...DEFAULT_BANNED_COMMANDS];
        bannedCommandsInput.value = DEFAULT_BANNED_COMMANDS.join('\n');
        saveSettings(currentSettings);
        if (bannedSaveStatus) {
          bannedSaveStatus.textContent = TRANSLATIONS[currentSettings.lang].banned_reset;
          setTimeout(() => { bannedSaveStatus.textContent = ''; }, 3000);
        }
      });
    }

    /* ===== LaTeX æ¸²æŸ“åŠŸèƒ½ ===== */
    let katexLoaded = false;
    let katexLoading = false;
    let latexObserver = null;

    // KaTeX CDN èµ„æº
    const KATEX_CSS = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css';
    const KATEX_JS = 'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js';

    // åŠ¨æ€åŠ è½½ KaTeX (ä»…åœ¨å¯ç”¨æ—¶åŠ è½½)
    function loadKaTeX() {
      return new Promise((resolve, reject) => {
        if (katexLoaded) { resolve(); return; }
        if (katexLoading) {
          // ç­‰å¾…åŠ è½½å®Œæˆ
          const check = setInterval(() => {
            if (katexLoaded) { clearInterval(check); resolve(); }
          }, 100);
          return;
        }

        katexLoading = true;
        const dict = TRANSLATIONS[currentSettings.lang];
        if (latexStatusEl) latexStatusEl.textContent = dict.latex_loading;

        // åŠ è½½ CSS
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = KATEX_CSS;
        document.head.appendChild(link);

        // åŠ è½½ JS
        const script = document.createElement('script');
        script.src = KATEX_JS;
        script.onload = () => {
          katexLoaded = true;
          katexLoading = false;
          if (latexStatusEl) latexStatusEl.textContent = dict.latex_ready;
          setTimeout(() => { if (latexStatusEl) latexStatusEl.textContent = ''; }, 2000);
          resolve();
        };
        script.onerror = () => {
          katexLoading = false;
          if (latexStatusEl) latexStatusEl.textContent = dict.latex_failed;
          reject(new Error('KaTeX load failed'));
        };
        document.head.appendChild(script);
      });
    }

    // æ¸²æŸ“å•ä¸ªå…¬å¼
    function renderLatex(formula, displayMode = false) {
      if (!window.katex) return null;
      try {
        return window.katex.renderToString(formula, {
          throwOnError: false,
          displayMode: displayMode
        });
      } catch (e) {
        return `<span class="latex-error">[LaTeX Error: ${e.message}]</span>`;
      }
    }

    // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹ä¸­çš„ LaTeX å…¬å¼
    function processLatexInText(textNode) {
      const text = textNode.textContent;
      // å—çº§å…¬å¼: $$...$$
      // è¡Œå†…å…¬å¼: $...$ (ä½†æ’é™¤ $$ å’Œå•ç‹¬çš„ $)
      const pattern = /(\$\$[\s\S]+?\$\$|\$(?!\$)(?:[^$\n]|\n(?!\n))+?\$(?!\$))/g;

      if (!pattern.test(text)) return false;
      pattern.lastIndex = 0;

      const fragment = document.createDocumentFragment();
      let lastIndex = 0;
      let match;

      while ((match = pattern.exec(text)) !== null) {
        // æ·»åŠ å…¬å¼å‰çš„æ™®é€šæ–‡æœ¬
        if (match.index > lastIndex) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
        }

        const fullMatch = match[0];
        const isBlock = fullMatch.startsWith('$$');
        const formula = isBlock ? fullMatch.slice(2, -2).trim() : fullMatch.slice(1, -1).trim();
        const rendered = renderLatex(formula, isBlock);

        if (rendered) {
          const wrapper = document.createElement(isBlock ? 'div' : 'span');
          wrapper.className = isBlock ? 'latex-block latex-rendered' : 'latex-rendered';
          // ä¿å­˜åŸå§‹å…¬å¼ç”¨äºè¿˜åŸ
          wrapper.dataset.latexOriginal = fullMatch;
          wrapper.innerHTML = rendered;
          fragment.appendChild(wrapper);
        } else {
          fragment.appendChild(document.createTextNode(fullMatch));
        }

        lastIndex = match.index + fullMatch.length;
      }

      // æ·»åŠ å‰©ä½™æ–‡æœ¬
      if (lastIndex < text.length) {
        fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
      }

      textNode.parentNode.replaceChild(fragment, textNode);
      return true;
    }

    // æ‰«æå¹¶æ¸²æŸ“ LaTeX å…¬å¼
    function scanAndRenderLatex() {
      if (!currentSettings.latexEnabled || !katexLoaded) return;

      // åªå¤„ç† AI å›å¤åŒºåŸŸ (.prose)
      const proseElements = reactApp.querySelectorAll('.prose:not(.opacity-70)');

      proseElements.forEach(prose => {
        // è·³è¿‡å·²å¤„ç†çš„
        if (prose.dataset.latexProcessed) return;

        // è·å–æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹
        const walker = document.createTreeWalker(prose, NodeFilter.SHOW_TEXT, null, false);
        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
          // è·³è¿‡ code/pre/script/style ä¸­çš„å†…å®¹
          const parent = node.parentNode;
          if (parent && /^(code|pre|script|style)$/i.test(parent.tagName)) continue;
          if (node.textContent.includes('$')) textNodes.push(node);
        }

        // å¤„ç†æ–‡æœ¬èŠ‚ç‚¹ (å€’åºé¿å…ç´¢å¼•é—®é¢˜)
        let hasLatex = false;
        for (let i = textNodes.length - 1; i >= 0; i--) {
          if (processLatexInText(textNodes[i])) hasLatex = true;
        }

        if (hasLatex) prose.dataset.latexProcessed = 'true';
      });
    }

    // è¿˜åŸæ‰€æœ‰å·²æ¸²æŸ“çš„ LaTeX å…¬å¼ä¸ºåŸå§‹æ–‡æœ¬
    function revertLatex() {
      // æŸ¥æ‰¾æ‰€æœ‰å·²æ¸²æŸ“çš„å…¬å¼å…ƒç´ 
      const renderedElements = reactApp.querySelectorAll('.latex-rendered');

      renderedElements.forEach(el => {
        const original = el.dataset.latexOriginal;
        if (original) {
          const textNode = document.createTextNode(original);
          el.parentNode.replaceChild(textNode, el);
        }
      });

      // æ¸…é™¤å¤„ç†æ ‡è®°
      reactApp.querySelectorAll('[data-latex-processed]').forEach(el => {
        delete el.dataset.latexProcessed;
      });
    }

    // åº”ç”¨ LaTeX è®¾ç½®
    async function applyLatexSettings() {
      // é”€æ¯ç°æœ‰ observer
      if (latexObserver) {
        latexObserver.disconnect();
        latexObserver = null;
      }

      if (!currentSettings.latexEnabled) {
        // ç¦ç”¨æ—¶ç«‹å³è¿˜åŸå…¬å¼
        revertLatex();
        return;
      }

      // åŠ è½½ KaTeX å¹¶å¼€å§‹ç›‘å¬
      try {
        await loadKaTeX();

        // åˆ›å»º observer ç›‘å¬æ–°å†…å®¹
        latexObserver = new MutationObserver(() => {
          clearTimeout(window.latexThrottleTimer);
          window.latexThrottleTimer = setTimeout(scanAndRenderLatex, 300);
        });
        latexObserver.observe(reactApp, { childList: true, subtree: true });

        // ç«‹å³æ‰«æå½“å‰å†…å®¹
        scanAndRenderLatex();
      } catch (e) {
        console.warn('[LaTeX] Init failed:', e.message);
      }
    }

    // LaTeX å¼€å…³äº‹ä»¶
    if (latexMasterToggle) {
      latexMasterToggle.addEventListener('change', () => {
        currentSettings.latexEnabled = latexMasterToggle.checked;
        saveSettings(currentSettings);
        applyLatexSettings();
      });
    }

    /* ===== F. AI Translator Logic ===== */
    const BRIDGE_URL = 'http://127.0.0.1:54321';
    let bridgeConnected = false;

    // Bridge Communication
    async function callBridge(endpoint, data) {
      try {
        const ctrl = new AbortController();
        const timeoutId = setTimeout(() => ctrl.abort(), 5000);
        const res = await fetch(`${BRIDGE_URL}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
          signal: ctrl.signal
        });
        clearTimeout(timeoutId);
        if (!res.ok) throw new Error(res.statusText);
        return await res.json();
      } catch (e) {
        console.warn('Bridge Call Failed:', e);
        return null;
      }
    }

    async function checkBridgeStatus() {
      const indicator = document.getElementById('bridge-status-indicator');
      const keyStatus = document.getElementById('key-existence-status');
      if (!indicator) return;
      try {
        const res = await fetch(`${BRIDGE_URL}/status`);
        if (res.ok) {
          const data = await res.json();
          bridgeConnected = true;
          indicator.className = 'bridge-status connected';
          indicator.title = 'Connected to Antigravity Bridge';

          if (keyStatus) {
            keyStatus.style.display = data.hasKey ? 'inline' : 'none';
          }
        } else {
          throw new Error('Status not ok');
        }
      } catch (e) {
        bridgeConnected = false;
        indicator.className = 'bridge-status error';
        indicator.title = 'Bridge Disconnected';
      }
    }

    // Save Key Logic
    const saveKeyBtn = document.getElementById('save-key-btn');
    if (saveKeyBtn) {
      saveKeyBtn.addEventListener('click', async () => {
        const keyInput = document.getElementById('translator-key');
        const statusEl = document.getElementById('key-save-status');
        if (!keyInput.value) return;

        statusEl.textContent = 'Saving...';
        const result = await callBridge('/save-key', { apiKey: keyInput.value });

        if (result && result.success) {
          statusEl.textContent = 'âœ“ Saved to Secure Storage';
          keyInput.value = ''; // Clear for security
          checkBridgeStatus(); // Refresh existence status
          setTimeout(() => statusEl.textContent = '', 3000);
        } else {
          statusEl.textContent = 'âœ— Save Failed (Check Bridge)';
        }
      });
    }

    // Translate Logic
    const TRANSLATE_ICON = '<svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><path d="M12.87 15.07l-2.54-2.51.03-.03A17.52 17.52 0 0014.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>';

    function createTranslateButton(textBlock) {
      // Find suitable container to append button - assuming parent is relative or we make it so
      const parent = textBlock.parentElement;
      if (!parent) return null;

      const btn = document.createElement('div');
      btn.className = 'translate-btn';
      btn.innerHTML = `${TRANSLATE_ICON} Translate`;
      btn.title = 'Translate AI Response';

      // KEY FIX: Prevent hover events from bubbling to parent
      // This is crucial to stop the parent from re-rendering and moving the button
      btn.addEventListener('mouseover', (e) => e.stopPropagation());
      btn.addEventListener('mouseenter', (e) => e.stopPropagation());
      btn.addEventListener('mouseleave', (e) => e.stopPropagation());
      btn.addEventListener('mouseout', (e) => e.stopPropagation());
      btn.addEventListener('mousedown', (e) => e.preventDefault()); // Prevent focus loss

      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!bridgeConnected) {
          alert('Bridge not connected! Please start the Bridge Extension.');
          return;
        }

        const originalText = textBlock.innerText; // use innerText to get visual text

        // Remove existing result if any
        let existingResult = parent.querySelector('.translation-result');
        if (existingResult) existingResult.remove();

        const dict = TRANSLATIONS[currentSettings.lang] || TRANSLATIONS.en;
        const resultDiv = document.createElement('div');
        resultDiv.className = 'translation-result';
        resultDiv.textContent = dict.translator_translating || 'Translating...';
        parent.appendChild(resultDiv);

        // Call Bridge
        // Message Translation: AI (Output) -> User (Input)
        const response = await callBridge('/translate', {
          text: originalText,
          sourceLang: document.getElementById('translator-ai-lang').value || 'English',
          targetLang: document.getElementById('translator-user-lang').value || 'Spanish',
          model: getSelectedModel()
        });

        if (response && response.translation) {
          resultDiv.textContent = response.translation;
        } else {
          resultDiv.textContent = dict.translator_failed || 'Translation failed';
        }
      });

      return btn;
    }

    function injectTranslateButtons() {
      const toggle = document.getElementById('translator-master-toggle');
      if (!toggle || !toggle.checked) return;

      // Target AI Responses (prose) and User Messages
      // Use :not(.opacity-70) to avoid 'thinking' blocks if desired, or include them
      const blocks = document.querySelectorAll('.prose:not(.opacity-70), .bg-gray-500\\/15 .whitespace-pre-wrap');

      blocks.forEach(block => {
        const parent = block.parentElement;
        if (!parent || parent.querySelector('.translate-btn')) return;

        // Ensure relative positioning for absolute button
        if (window.getComputedStyle(parent).position === 'static') {
          parent.style.position = 'relative';
        }

        const btn = createTranslateButton(block);
        if (btn) parent.appendChild(btn);
      });

      // Inject Input Translator
      injectInputTranslator();
    }

    function injectInputTranslator() {
      // Strategy 1: Find Textareas
      let mainInput = null;
      const inputs = [
        ...document.querySelectorAll('textarea'),
        ...document.querySelectorAll('div[contenteditable="true"]'),
        ...document.querySelectorAll('[role="textbox"]')
      ];

      inputs.forEach(t => {
        // Exclude our own settings inputs
        if (t.id === 'banned-commands-input' || t.id === 'translator-key') return;

        // Exclude hidden inputs
        if (t.offsetHeight === 0) return;

        // Heuristics to find the REAL input
        const style = window.getComputedStyle(t);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden';
        if (!isVisible) return;

        // Check for specific traits of the chat input
        // 1. Placeholder often contains "Ask", "Type", "Chat"
        const placeholder = t.getAttribute('placeholder') || t.getAttribute('aria-placeholder') || '';
        // 2. Class often contains "input" or "editor"
        const className = t.className || '';

        // Accept if it looks like the main input
        if (placeholder || className.includes('input') || className.includes('editor') || t.tagName === 'TEXTAREA') {
          // Prefer the one that is likely the chat input (often larger or last one)
          mainInput = t;
        }
      });

      // 0. CLEANUP REMOVED: Do not blindly remove buttons here to avoid flicker loops!

      if (!mainInput) return;

      // Find the "Footer Toolbar"
      // Usually it's in the same wrapper, or a sibling of the input's container
      let toolbar = null;
      let parent = mainInput.parentElement;

      // Look up to 3 levels up for a container that looks like a toolbar
      // Strategy: Look for siblings of the input (or input wrapper)
      const potentialToolbars = [];
      const siblings = Array.from(parent.children).filter(c => c !== mainInput);
      potentialToolbars.push(...siblings);

      // Also check siblings of parent if input is deeply nested
      if (parent.parentElement) {
        const uncles = Array.from(parent.parentElement.children).filter(c => c !== parent);
        potentialToolbars.push(...uncles);
      }
      // Check Great-Uncles (Wrapper -> InputArea -> Footer)
      if (parent.parentElement && parent.parentElement.parentElement) {
        const greatUncles = Array.from(parent.parentElement.parentElement.children).filter(c => c !== parent.parentElement);
        potentialToolbars.push(...greatUncles);
      }

      // PRIORITY STRATEGY: Look for model selector buttons first
      // Find buttons with model names and use their parent as toolbar
      const allButtons = document.querySelectorAll('button, [role="button"]');
      for (const btn of allButtons) {
        const text = btn.innerText || btn.textContent || '';
        if (text.includes('Gemini') || text.includes('Claude') || text.includes('GPT') || text.includes('Planning')) {
          toolbar = btn.parentElement;
          break;
        }
      }

      // Filter for the best candidate
      for (const el of potentialToolbars) {
        if (el.offsetHeight > 0 && el.offsetHeight < 60) {
          const html = el.innerHTML;
          const text = el.innerText;
          // Improved heuristic: Bottom bars often contain specific icons or keywords
          if (
            text.includes('Gemini') ||
            text.includes('Claude') ||
            text.includes('GPT') ||
            text.includes('Model') ||
            text.includes('Planning') ||
            html.includes('model-selector') ||
            html.includes('aria-haspopup="listbox"') ||
            (el.children.length >= 2 && el.querySelector('button'))
          ) {
            toolbar = el;
            break;
          }
        }
      }

      // If we found a toolbar, use it. Otherwise, use parent but specific styling.
      const targetContainer = toolbar || parent;

      // KEY FIX: Idempotency Check
      // If the correct container ALREADY has our unique button, DO NOTHING.
      // This prevents the destroy-recreate loop that causes flickering.
      if (targetContainer.querySelector('#input-translate-btn-unique')) {
        return;
      }

      // Clean up buttons elsewhere (e.g. if we moved to a new better container)
      const oldBtns = document.querySelectorAll('.input-translate-btn');
      oldBtns.forEach(b => b.remove());

      // If we are injecting into parent (fallback), ensure relative
      let isAbsolute = false;
      if (targetContainer === parent) {
        parent.classList.add('input-wrapper-relative');
        isAbsolute = true;
      }

      const btn = document.createElement('button');
      btn.id = 'input-translate-btn-unique'; // Unique ID
      btn.className = isAbsolute ? 'input-translate-btn input-translate-btn-absolute' : 'input-translate-btn';
      btn.innerHTML = `${TRANSLATE_ICON} Translate Selection`;
      btn.title = 'Select text to translate';

      // Prevent focus loss when clicking button
      btn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation(); // FIX: Isolate the event to prevent interference
      });

      // KEY FIX: Prevent hover events from bubbling to parent
      // This stops React/Parent from re-rendering (and killing our button) when we hover
      ['mouseover', 'mouseenter', 'mouseleave', 'mouseout'].forEach(evt => {
        btn.addEventListener(evt, (e) => e.stopPropagation());
      });

      btn.addEventListener('click', (e) => handleTranslateClick(e, btn));

      // NOTE: Focus tracking moved to global "Focus Tracker" section (single listener)

      // Insert logic: Simply append to end of toolbar
      targetContainer.appendChild(btn);
    }

    // Non-blocking error display that preserves focus - supports i18n
    function showTranslatorMessage(messageOrKey, isError = true, useI18n = true) {
      // Get localized message if key exists in dictionary
      let message = messageOrKey;
      if (useI18n && typeof TRANSLATIONS !== 'undefined' && typeof currentSettings !== 'undefined') {
        const dict = TRANSLATIONS[currentSettings.lang] || TRANSLATIONS.en;
        if (dict[messageOrKey]) {
          message = dict[messageOrKey];
        }
      }

      // Use existing toast system if available, or create a temporary one
      const existingToast = document.querySelector('.copy-toast');
      if (existingToast) {
        existingToast.textContent = message;
        existingToast.style.background = isError ? '#ff4444' : '#4CAF50';
        existingToast.classList.add('show');
        setTimeout(() => existingToast.classList.remove('show'), 3000);
      } else {
        // Fallback: Create inline notification
        const toast = document.createElement('div');
        toast.style.cssText = `
          position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
          background: ${isError ? '#ff4444' : '#4CAF50'}; color: white;
          padding: 10px 20px; border-radius: 8px; z-index: 99999;
          font-size: 13px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          animation: fadeIn 0.2s ease;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
      }
    }

    async function handleTranslateClick(e, btn) {
      e.preventDefault();
      e.stopPropagation();

      // Rate limiting: prevent spam clicks
      if (btn.disabled) return;
      btn.disabled = true;
      btn.style.opacity = '0.5';

      const targetInput = window.lastFocusedInput;

      // Get i18n dictionary
      const dict = TRANSLATIONS[currentSettings.lang] || TRANSLATIONS.en;

      // Helper to safely restore focus
      const restoreFocus = () => {
        if (targetInput) {
          setTimeout(() => {
            try { targetInput.focus(); } catch (e) { }
          }, 50); // Small delay to ensure DOM is stable
        }
      };

      let originalBtnText = btn.innerHTML; // Capture initial text

      try {
        if (!bridgeConnected) {
          showTranslatorMessage('translator_bridge_error');
          return;
        }

        // Double check selection specifically
        const selection = window.getSelection();
        let text = selection.toString();

        // If textarea, get text via properties
        if (targetInput && targetInput.tagName === 'TEXTAREA') {
          text = targetInput.value.substring(targetInput.selectionStart, targetInput.selectionEnd);
        }

        if (!text || !text.trim()) {
          showTranslatorMessage('translator_select_text');
          return;
        }

        btn.textContent = dict.translator_translating || 'Translating...';

        const response = await callBridge('/translate', {
          text: text,
          sourceLang: document.getElementById('translator-user-lang').value || 'Spanish',
          targetLang: document.getElementById('translator-ai-lang').value || 'English',
          model: getSelectedModel()
        });

        if (response && response.translation) {
          if (targetInput && targetInput.tagName === 'TEXTAREA') {
            // Textarea replacement
            const start = targetInput.selectionStart;
            const end = targetInput.selectionEnd;
            targetInput.setRangeText(response.translation, start, end, 'select');
            targetInput.dispatchEvent(new Event('input', { bubbles: true }));
          } else {
            // ContentEditable replacement (uses Selection API directly)
            if (!document.execCommand('insertText', false, response.translation)) {
              showTranslatorMessage('translator_copied', false);
              navigator.clipboard.writeText(response.translation);
            }
          }
        } else {
          showTranslatorMessage('translator_failed', true, true);
        }
      } catch (err) {
        console.error('[Translator] Error:', err);
        showTranslatorMessage('translator_error', true, true);
      } finally {
        // ALWAYS restore button text and re-enable
        btn.innerHTML = originalBtnText;
        btn.disabled = false;
        btn.style.opacity = '1';
        // ALWAYS restore focus with delay
        restoreFocus();
      }
    }

    function applyTranslatorSettings() {
      // Clean up old observer
      if (window.translatorObserver) {
        window.translatorObserver.disconnect();
        window.translatorObserver = null;
      }

      const toggle = document.getElementById('translator-master-toggle');
      if (toggle && toggle.checked) {
        window.translatorObserver = new MutationObserver(() => {
          // Debounce
          clearTimeout(window.transThrottle);
          window.transThrottle = setTimeout(injectTranslateButtons, 500);
        });
        window.translatorObserver.observe(document.getElementById('react-app'), { childList: true, subtree: true });

        injectTranslateButtons();
        checkBridgeStatus();

        // Clear previous interval if any
        if (window.bridgeInterval) clearInterval(window.bridgeInterval);
        window.bridgeInterval = setInterval(checkBridgeStatus, 10000);

        // Heartbeat for Input Translator (Reactive fallback)
        if (window.inputTransHeartbeat) clearInterval(window.inputTransHeartbeat);
        window.inputTransHeartbeat = setInterval(injectInputTranslator, 2000);
      } else {
        if (window.bridgeInterval) clearInterval(window.bridgeInterval);
        if (window.inputTransHeartbeat) clearInterval(window.inputTransHeartbeat);
        document.querySelectorAll('.translate-btn').forEach(b => b.remove());
        document.querySelectorAll('.translation-result').forEach(b => b.remove());
        document.querySelectorAll('.input-translate-btn').forEach(b => b.remove());
      }
    }

    /* ===== Focus Tracker ===== */
    window.lastFocusedInput = null;
    document.addEventListener('focusin', (e) => {
      const t = e.target;
      // Track if it's an editable element (textarea, input text, or contenteditable)
      if (
        t.tagName === 'TEXTAREA' ||
        (t.tagName === 'INPUT' && t.type === 'text') ||
        t.getAttribute('contenteditable') === 'true' ||
        t.getAttribute('role') === 'textbox'
      ) {
        // Ignore our own settings
        if (t.id !== 'translator-key' && t.id !== 'translator-custom-model' && t.id !== 'banned-commands-input') {
          window.lastFocusedInput = t;
        }
      }
    });

    /* ===== åˆå§‹åŒ– ===== */
    function initUI() {
      // 0. æ˜¾ç¤ºå½“å‰ç‰ˆæœ¬å·
      const versionEl = document.getElementById('current-version');
      if (versionEl) versionEl.textContent = 'v' + APP_VERSION;

      // 1. è®¾ç½®æ§ä»¶çŠ¶æ€
      masterToggle.checked = currentSettings.masterEnabled;
      copyMasterToggle.checked = currentSettings.copyEnabled;
      hotkeyMasterToggle.checked = currentSettings.hotkeyEnabled;
      sendHotkeySelect.value = currentSettings.sendHotkey;

      COLOR_CONFIGS.forEach(c => {
        const t = document.getElementById(`toggle-${c.id}`);
        const col = document.getElementById(`color-${c.id}`);
        if (t) t.checked = currentSettings.colors[c.id].enabled;
        if (col) col.value = currentSettings.colors[c.id].color;
      });

      COPY_CONFIGS.forEach(c => {
        const t = document.getElementById(`toggle-${c.id}`);
        if (t) t.checked = currentSettings.copy[c.id]?.enabled ?? true;
      });

      // å­—ä½“å¤§å°æ§ä»¶åˆå§‹åŒ–
      fontsizeMasterToggle.checked = currentSettings.fontsizeMasterEnabled;
      FONTSIZE_CONFIGS.forEach(c => {
        const t = document.getElementById(`toggle-fontsize-${c.id}`);
        const sizeEl = document.getElementById(`fontsize-${c.id}`);
        if (t) t.checked = currentSettings.fontsizes[c.id].enabled;
        if (sizeEl) sizeEl.value = currentSettings.fontsizes[c.id].size;
      });

      // 2. è‡ªåŠ¨æ“ä½œåˆå§‹åŒ–
      if (autoAcceptMasterToggle) {
        autoAcceptMasterToggle.checked = currentSettings.autoAcceptEnabled;
      }
      renderPatternCheckboxes();
      if (bannedCommandsInput) {
        bannedCommandsInput.value = currentSettings.bannedCommands.join('\n');
      }
      updateStatsUI();

      // 3. åº”ç”¨åŠŸèƒ½
      applyColorSettings();
      applyFontsizeSettings();
      applyCopySettings();
      applyHotkeySettings();
      applyAutoAcceptSettings();
      updateLanguage();

      // LaTeX åˆå§‹åŒ–
      if (latexMasterToggle) {
        latexMasterToggle.checked = currentSettings.latexEnabled;
      }
      if (currentSettings.latexEnabled) {
        applyLatexSettings();
      }

      // 4. ç³»ç»Ÿè®¾ç½®åˆå§‹åŒ–
      const autoUpdateToggle = document.getElementById('auto-update-toggle');
      const manualUpdateBtn = document.getElementById('manual-update-btn');

      if (autoUpdateToggle) {
        autoUpdateToggle.checked = currentSettings.autoUpdateEnabled;
        autoUpdateToggle.addEventListener('change', () => {
          currentSettings.autoUpdateEnabled = autoUpdateToggle.checked;
          saveSettings(currentSettings);
        });
      }

      if (manualUpdateBtn) {
        manualUpdateBtn.addEventListener('click', manualCheckUpdate);
      }

      // 5. å¯åŠ¨æ—¶ç‰ˆæœ¬æ£€æµ‹ï¼ˆå¦‚æœå¯ç”¨ï¼‰
      if (currentSettings.autoUpdateEnabled) {
        setTimeout(checkForUpdate, 10000);
      }

      // 6. Translator åˆå§‹åŒ–
      const transToggle = document.getElementById('translator-master-toggle');
      const transModel = document.getElementById('translator-model');
      const transUserLang = document.getElementById('translator-user-lang');
      const transAiLang = document.getElementById('translator-ai-lang');

      if (transToggle) {
        transToggle.checked = currentSettings.translatorEnabled;
        transToggle.addEventListener('change', () => {
          currentSettings.translatorEnabled = transToggle.checked;
          saveSettings(currentSettings);
          applyTranslatorSettings();
        });
      }

      // Restore saved model/language values
      const customModelContainer = document.getElementById('custom-model-container');
      const customModelInput = document.getElementById('translator-custom-model');

      // Helper to show/hide custom model input
      function updateCustomModelVisibility() {
        if (transModel && customModelContainer) {
          const isCustom = transModel.value === '__custom__';
          customModelContainer.style.display = isCustom ? 'block' : 'none';
        }
      }

      if (transModel) {
        // If saved model is custom, select __custom__ and restore custom value
        if (currentSettings.translatorModel === '__custom__' ||
          (currentSettings.translatorCustomModel && !Array.from(transModel.options).find(o => o.value === currentSettings.translatorModel))) {
          transModel.value = '__custom__';
          if (customModelInput) {
            customModelInput.value = currentSettings.translatorCustomModel || '';
          }
        } else {
          transModel.value = currentSettings.translatorModel;
        }
        updateCustomModelVisibility();

        transModel.addEventListener('change', () => {
          currentSettings.translatorModel = transModel.value;
          saveSettings(currentSettings);
          updateCustomModelVisibility();
        });
      }

      // Custom model input persistence
      if (customModelInput) {
        customModelInput.value = currentSettings.translatorCustomModel || '';
        customModelInput.addEventListener('input', () => {
          currentSettings.translatorCustomModel = customModelInput.value.trim();
          saveSettings(currentSettings);
        });
      }

      if (transUserLang) {
        transUserLang.value = currentSettings.translatorUserLang;
        transUserLang.addEventListener('change', () => {
          currentSettings.translatorUserLang = transUserLang.value;
          saveSettings(currentSettings);
        });
      }
      if (transAiLang) {
        transAiLang.value = currentSettings.translatorAiLang;
        transAiLang.addEventListener('change', () => {
          currentSettings.translatorAiLang = transAiLang.value;
          saveSettings(currentSettings);
        });
      }

      // API Key visibility toggle
      const toggleKeyBtn = document.getElementById('toggle-key-visibility');
      const keyInput = document.getElementById('translator-key');
      if (toggleKeyBtn && keyInput) {
        toggleKeyBtn.addEventListener('click', () => {
          if (keyInput.type === 'password') {
            keyInput.type = 'text';
            toggleKeyBtn.textContent = 'ğŸ™ˆ';
          } else {
            keyInput.type = 'password';
            toggleKeyBtn.textContent = 'ğŸ‘';
          }
        });
      }

      applyTranslatorSettings();
    }

    if (document.readyState !== 'loading') initUI();
    else document.addEventListener('DOMContentLoaded', initUI);
  </script>
</body>

</html>